<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Development Plan</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body class="page-default">
    <header class="thematic-header">
        <div class="logo">
            <a href="index.html">Thematic</a>
        </div>
        <div class="nav-links">
            <button class="auth-button" onclick="window.location.href='login.html'">Login</button>
            <button class="auth-button" onclick="window.location.href='register.html'">Register</button>
        </div>
    </header>

    <div class="result-container">
        <h1>Your Development Plan</h1>
        <div id="result"></div>

        <button onclick="downloadMarkdown()">Download as Markdown</button>
        <button onclick="downloadZip()">Download as ZIP</button>
    </div>

    <script>
        // Load the API result from localStorage
        const result = localStorage.getItem('apiResult') || 'No result available.';
        const resultDiv = document.getElementById('result');

        // Parse the result (assuming it's plain text with sections)
        const sections = result.split('\n\n');
        let htmlContent = '';

        sections.forEach(section => {
            const lines = section.trim().split('\n');
            const heading = lines[0];
            const content = lines.slice(1).join('\n');

            if (!heading) return; // Skip empty sections

            htmlContent += `<h2>${heading}</h2>`;

            // Handle specific sections with tables or code
            if (heading === 'Technical Requirements') {
                // Assuming content is in a table-like format: Component | Technology | Version
                const rows = content.split('\n').map(row => row.split('|').map(cell => cell.trim()));
                if (rows.length > 0) {
                    htmlContent += '<table>';
                    rows.forEach((row, index) => {
                        if (index === 0) {
                            htmlContent += '<tr>' + row.map(cell => `<th>${cell}</th>`).join('') + '</tr>';
                        } else {
                            htmlContent += '<tr>' + row.map(cell => `<td>${cell}</td>`).join('') + '</tr>';
                        }
                    });
                    htmlContent += '</table>';
                }
            } else if (heading === 'Data Architecture' && content.includes('Field | Type | Constraints')) {
                const rows = content.split('\n');
                const tableStart = rows.findIndex(line => line.includes('Field | Type | Constraints'));
                const tableRows = rows.slice(tableStart).filter(line => line.includes('|')).map(row => row.split('|').map(cell => cell.trim()));
                if (tableRows.length > 0) {
                    htmlContent += '<table>';
                    tableRows.forEach((row, index) => {
                        if (index === 0) {
                            htmlContent += '<tr>' + row.map(cell => `<th>${cell}</th>`).join('') + '</tr>';
                        } else {
                            htmlContent += '<tr>' + row.map(cell => `<td>${cell}</td>`).join('') + '</tr>';
                        }
                    });
                    htmlContent += '</table>';
                    const remainingContent = rows.slice(0, tableStart).join('\n') + '\n' + rows.slice(tableStart + tableRows.length).join('\n');
                    if (remainingContent.trim()) {
                        htmlContent += formatContentWithCode(remainingContent);
                    }
                } else {
                    htmlContent += formatContentWithCode(content);
                }
            } else if (heading === 'API Design') {
                const rows = content.split('\n').filter(line => line.includes('|')).map(row => row.split('|').map(cell => cell.trim()));
                if (rows.length > 0) {
                    htmlContent += '<table>';
                    rows.forEach((row, index) => {
                        if (index === 0) {
                            htmlContent += '<tr>' + row.map(cell => `<th>${cell}</th>`).join('') + '</tr>';
                        } else {
                            htmlContent += '<tr>' + row.map(cell => `<td>${cell}</td>`).join('') + '</tr>';
                        }
                    });
                    htmlContent += '</table>';
                }
                const remainingContent = content.split('\n').filter(line => !line.includes('|')).join('\n');
                if (remainingContent.trim()) {
                    htmlContent += formatContentWithCode(remainingContent);
                }
            } else if (heading.includes('Core Features Implementation') || heading.includes('User Workflow') || heading.includes('Key Features Development') || heading.includes('Development Workflow')) {
                // Handle numbered lists with potential code
                const items = content.split('\n').filter(line => line.match(/^\d+\./));
                if (items.length > 0) {
                    htmlContent += '<ol>';
                    let currentItem = '';
                    content.split('\n').forEach(line => {
                        if (line.match(/^\d+\./)) {
                            if (currentItem) {
                                htmlContent += `<li>${formatContentWithCode(currentItem)}</li>`;
                            }
                            currentItem = line.replace(/^\d+\.\s*/, '');
                        } else {
                            currentItem += '\n' + line;
                        }
                    });
                    if (currentItem) {
                        htmlContent += `<li>${formatContentWithCode(currentItem)}</li>`;
                    }
                    htmlContent += '</ol>';
                } else {
                    htmlContent += formatContentWithCode(content);
                }
            } else {
                // Default: paragraphs with potential code
                htmlContent += formatContentWithCode(content);
            }
        });

        resultDiv.innerHTML = htmlContent;

        // Function to format content with code blocks
        function formatContentWithCode(content) {
            const lines = content.split('\n');
            let inCodeBlock = false;
            let codeContent = '';
            let html = '<p>';

            lines.forEach(line => {
                if (line.startsWith('    ')) { // Detect code by indentation (4 spaces)
                    if (!inCodeBlock) {
                        inCodeBlock = true;
                        if (html !== '<p>') html += '</p>';
                        codeContent = line.slice(4) + '\n';
                    } else {
                        codeContent += line.slice(4) + '\n';
                    }
                } else {
                    if (inCodeBlock) {
                        inCodeBlock = false;
                        html += `<pre><code>${codeContent.trim()}</code></pre>`;
                        codeContent = '';
                        html += '<p>';
                    }
                    if (line.trim()) {
                        html += line + '<br>';
                    }
                }
            });

            if (inCodeBlock) {
                html += `<pre><code>${codeContent.trim()}</code></pre>`;
            }
            html += '</p>';
            return html;
        }

        // Download as Markdown
        function downloadMarkdown() {
            const blob = new Blob([result], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'development-plan.md';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Download as ZIP
        function downloadZip() {
            const zip = new JSZip();
            // Add the main Markdown file
            zip.file('development-plan.md', result);
            // Add a README with the Development Workflow
            const workflowSection = sections.find(section => section.startsWith('Development Workflow')) || 'Development Workflow\nNo workflow provided.';
            zip.file('README.md', workflowSection);
            // Generate the ZIP file
            zip.generateAsync({ type: 'blob' }).then(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'development-plan.zip';
                a.click();
                URL.revokeObjectURL(url);
            });
        }
    </script>
</body>
</html>