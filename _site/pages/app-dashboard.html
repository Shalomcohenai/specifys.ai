<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <meta name="theme-color" content="#000000">
    <title>App Dashboard - Specifys.ai</title>
    <meta name="description" content="Manage your app project">
    <meta name="keywords" content="AI development tools, app specification generator, no-code platform, AI-powered planning, vibe coding, AI app builder, specification generator, market research tool, app planning tool, development tools, AI tools">
    <meta name="author" content="Specifys.ai">
    <meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1">
    
    <!-- Content Security Policy - Removed to fix Google Analytics/Ads issues -->
    
    <!-- Canonical URL -->
    
    <link rel="canonical" href="http://localhost:4000/pages/app-dashboard.html">
    
    
    <!-- Open Graph -->
    <meta property="og:site_name" content="Specifys.ai">
    <meta property="og:title" content="App Dashboard">
    <meta property="og:description" content="Manage your app project">
    <meta property="og:type" content="website">
    <meta property="og:url" content="http://localhost:4000/pages/app-dashboard.html">
    <meta property="og:image" content="http://localhost:4000/assets/images/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:locale" content="en_US">
    
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@specifysai">
    <meta name="twitter:creator" content="@specifysai">
    <meta name="twitter:title" content="App Dashboard">
    <meta name="twitter:description" content="Manage your app project">
    <meta name="twitter:image" content="http://localhost:4000/assets/images/og-image.png">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">
    
      
        <link rel="stylesheet" href="/assets/css/pages/app-dashboard.css">
      
    
    
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Montserrat:wght@300;400;500;600;700&family=Poppins:wght@300;400;500;600;700&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Mermaid for diagrams (used in demo, spec, research pages) -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js"></script>
    
    <!-- Marked for markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
    
    <!-- Highlight.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- jsPDF for PDF export (used in research pages) -->
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-RWBT69JCM7"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-RWBT69JCM7');
</script>


    <script>
// Central Analytics Event Tracking System for Specifys.ai
// This file contains reusable tracking functions for consistent analytics across the site

// Check if gtag is available
function isGtagAvailable() {
  return typeof gtag !== 'undefined';
}

// Track button clicks with detailed categorization
function trackButtonClick(buttonName, category, source, additionalData = {}) {
  if (isGtagAvailable()) {
    gtag('event', 'click', {
      'event_category': category || 'Button Click',
      'event_label': buttonName,
      'event_source': source || 'unknown',
      ...additionalData
    });
  }
}

// Track CTA (Call-to-Action) clicks
function trackCTA(ctaName, location) {
  if (isGtagAvailable()) {
    gtag('event', 'cta_click', {
      'event_category': 'CTA',
      'event_label': ctaName,
      'cta_location': location
    });
  }
}

// Track navigation events
function trackNavigation(destination, source) {
  if (isGtagAvailable()) {
    gtag('event', 'navigation', {
      'event_category': 'Navigation',
      'event_label': destination,
      'navigation_source': source
    });
  }
}

// Track tool usage
function trackToolUsage(toolName, action) {
  if (isGtagAvailable()) {
    gtag('event', 'tool_usage', {
      'event_category': 'Tools',
      'event_label': toolName,
      'tool_action': action
    });
  }
}

// Track form submissions
function trackFormSubmit(formName, formType) {
  if (isGtagAvailable()) {
    gtag('event', 'form_submit', {
      'event_category': 'Form',
      'event_label': formName,
      'form_type': formType
    });
  }
}

// Track user authentication events
function trackAuthEvent(action, method) {
  if (isGtagAvailable()) {
    gtag('event', action, {
      'event_category': 'Authentication',
      'event_label': action,
      'auth_method': method || 'email'
    });
  }
}

// Track downloads
function trackDownload(fileName, fileType) {
  if (isGtagAvailable()) {
    gtag('event', 'download', {
      'event_category': 'Downloads',
      'event_label': fileName,
      'file_type': fileType
    });
  }
}

// Track spec/result generations
function trackGeneration(type, mode) {
  if (isGtagAvailable()) {
    gtag('event', 'generation_start', {
      'event_category': 'Generation',
      'event_label': type,
      'generation_mode': mode
    });
  }
}

// Track generation completion
function trackGenerationComplete(type, mode, success) {
  if (isGtagAvailable()) {
    gtag('event', 'generation_complete', {
      'event_category': 'Generation',
      'event_label': type,
      'generation_mode': mode,
      'success': success
    });
  }
}

// Track external link clicks
function trackExternalLink(linkUrl, linkText) {
  if (isGtagAvailable()) {
    gtag('event', 'click', {
      'event_category': 'External Link',
      'event_label': linkText || linkUrl,
      'link_url': linkUrl
    });
  }
}

// Track modal interactions
function trackModal(modalName, action) {
  if (isGtagAvailable()) {
    gtag('event', 'modal_' + action, {
      'event_category': 'Modal',
      'event_label': modalName,
      'modal_action': action
    });
  }
}

// Track FAQ interactions
function trackFAQ(question, action) {
  if (isGtagAvailable()) {
    gtag('event', 'faq_' + action, {
      'event_category': 'FAQ',
      'event_label': question,
      'faq_action': action
    });
  }
}

// Track search actions
function trackSearch(searchTerm, searchType) {
  if (isGtagAvailable()) {
    gtag('event', 'search', {
      'event_category': 'Search',
      'search_term': searchTerm,
      'search_type': searchType
    });
  }
}

// Track video/demo views
function trackDemoView(demoName, viewDuration) {
  if (isGtagAvailable()) {
    gtag('event', 'demo_view', {
      'event_category': 'Demo',
      'event_label': demoName,
      'view_duration': viewDuration
    });
  }
}

// Track user engagement time
function trackEngagement(pageName, timeSpent) {
  if (isGtagAvailable()) {
    gtag('event', 'user_engagement', {
      'event_category': 'Engagement',
      'event_label': pageName,
      'engagement_time_msec': timeSpent
    });
  }
}

// Track errors
function trackError(errorType, errorMessage, errorLocation) {
  if (isGtagAvailable()) {
    gtag('event', 'error', {
      'event_category': 'Error',
      'event_label': errorType,
      'error_message': errorMessage,
      'error_location': errorLocation
    });
  }
}

// Track user preferences
function trackPreference(preferenceName, preferenceValue) {
  if (isGtagAvailable()) {
    gtag('event', 'preference_change', {
      'event_category': 'Preferences',
      'event_label': preferenceName,
      'preference_value': preferenceValue
    });
  }
}

// Track scroll depth
let scrollDepthTracked = {25: false, 50: false, 75: false, 100: false};
function initScrollTracking(pageName) {
  window.addEventListener('scroll', function() {
    const scrollPercent = Math.round((window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100);
    
    if (scrollPercent >= 25 && !scrollDepthTracked[25]) {
      scrollDepthTracked[25] = true;
      if (isGtagAvailable()) {
        gtag('event', 'scroll', {
          'event_category': 'Scroll Depth',
          'event_label': pageName,
          'scroll_depth': '25%'
        });
      }
    }
    if (scrollPercent >= 50 && !scrollDepthTracked[50]) {
      scrollDepthTracked[50] = true;
      if (isGtagAvailable()) {
        gtag('event', 'scroll', {
          'event_category': 'Scroll Depth',
          'event_label': pageName,
          'scroll_depth': '50%'
        });
      }
    }
    if (scrollPercent >= 75 && !scrollDepthTracked[75]) {
      scrollDepthTracked[75] = true;
      if (isGtagAvailable()) {
        gtag('event', 'scroll', {
          'event_category': 'Scroll Depth',
          'event_label': pageName,
          'scroll_depth': '75%'
        });
      }
    }
    if (scrollPercent >= 100 && !scrollDepthTracked[100]) {
      scrollDepthTracked[100] = true;
      if (isGtagAvailable()) {
        gtag('event', 'scroll', {
          'event_category': 'Scroll Depth',
          'event_label': pageName,
          'scroll_depth': '100%'
        });
      }
    }
  });
}

// Auto-initialize scroll tracking when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
  const pageName = document.title || window.location.pathname;
  initScrollTracking(pageName);
});
</script>


    <!-- Structured Data (JSON-LD) for SEO -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "Organization",
      "name": "Specifys.ai",
      "url": "https://specifys-ai.com",
      "logo": "https://specifys-ai.com/favicon.ico",
      "description": "AI-powered app planning and specification generation platform",
      "sameAs": [
        "https://www.linkedin.com/company/specifys-ai/"
      ],
      "contactPoint": {
        "@type": "ContactPoint",
        "email": "specifysai@gmail.com",
        "contactType": "Customer Service"
      }
    },
    {
      "@type": "WebSite",
      "name": "Specifys.ai",
      "url": "https://specifys-ai.com",
      "description": "Plan your app smarter with AI-driven insights and tools",
      "potentialAction": {
        "@type": "SearchAction",
        "target": "https://specifys-ai.com/pages/ToolPicker.html?q={search_term_string}",
        "query-input": "required name=search_term_string"
      }
    },
    {
      "@type": "SoftwareApplication",
      "name": "Specifys.ai",
      "applicationCategory": "DevelopmentApplication",
      "operatingSystem": "Web",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.8",
        "ratingCount": "250"
      },
      "description": "AI-powered app planning platform with specification generator, market research tools, and vibe coding tools map"
    }
  ]
}
</script>


</head>


<body>
    <!-- Header -->
    <!-- Skip to main content link for accessibility -->
<a href="#main-content" class="skip-link">Skip to main content</a>

<!-- Header -->
<header class="thematic-header" role="banner">
    <div class="header-center">
        <div class="logo">
            <a href="/" aria-label="Specifys.ai homepage">
                <span class="logo-text">Specifys<span class="logo-dot">.</span>AI</span>
            </a>
        </div>
    </div>
    <div class="header-right">
        <div class="auth-buttons" id="auth-buttons">
            <!-- Will be populated by auth system -->
        </div>
    </div>
</header>

<style>
/* Logo dark grey color - adjusted size */
.logo a,
.logo-text {
    color: #333 !important;
    font-size: 1.66rem !important;
}

/* Only the dot in cyan */
.logo-dot {
    color: #0078d4 !important;
}

.logo a:hover {
    color: #444 !important;
}

.logo a:hover .logo-dot {
    color: #005ea2 !important;
}

/* Mobile adjustments */
@media (max-width: 768px) {
    .logo a,
    .logo-text {
        font-size: 1.22rem !important;
    }
}

@media (max-width: 480px) {
    .logo a,
    .logo-text {
        font-size: 1.11rem !important;
    }
}
</style>


    
    <!-- Main Content -->
    <main id="main-content" class="main-content">
            <main class="container">
        <!-- Dashboard Header -->
        <div class="dashboard-section">
            <div class="dashboard-overview">
                <div class="dashboard-title">
                    <h1 id="app-name">App Dashboard</h1>
                </div>
                <div class="dashboard-stats">
                    <div class="stat-item">
                        <span class="stat-number" id="tasks-count">0</span>
                        <span class="stat-label">Tasks</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" id="milestones-count">0</span>
                        <span class="stat-label">Milestones</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" id="notes-count">0</span>
                        <span class="stat-label">Notes</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" id="versions-count">0</span>
                        <span class="stat-label">Versions</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" id="budget-used">$0</span>
                        <span class="stat-label">Budget Used</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Unified Project Management Dashboard (Full Width) -->
        <div class="dashboard-section full-width unified-dashboard">
            <div class="tabbed-section">
                <div class="tab-header">
                    <div class="tab-buttons">
                        <button class="tab-button active" onclick="switchUnifiedTab('specs')" data-tab="specs">
                            <i class="fas fa-clipboard-list"></i> Specifications
                        </button>
                        <button class="tab-button" onclick="switchUnifiedTab('research')" data-tab="research">
                            <i class="fas fa-search"></i> Market Research
                        </button>
                        <button class="tab-button" onclick="switchUnifiedTab('tasks')" data-tab="tasks">
                            <i class="fas fa-tasks"></i> Tasks
                        </button>
                        <button class="tab-button" onclick="switchUnifiedTab('notes')" data-tab="notes">
                            <i class="fas fa-sticky-note"></i> Developer Notes
                        </button>
                        <button class="tab-button" onclick="switchUnifiedTab('milestones')" data-tab="milestones">
                            <i class="fas fa-bullseye"></i> Milestones
                        </button>
                        <button class="tab-button" onclick="switchUnifiedTab('features')" data-tab="features">
                            <i class="fas fa-rocket"></i> Feature List
                        </button>
                        <button class="tab-button" onclick="switchUnifiedTab('expenses')" data-tab="expenses">
                            <i class="fas fa-dollar-sign"></i> Expenses
                        </button>
                    </div>
                        <div class="tab-actions" id="unified-tab-actions">
                            <div class="action-buttons">
                                <button class="plus-button" onclick="redirectToSpecsCreator()" title="Create New Specification">+</button>
                            </div>
                        </div>
                </div>
                <div class="tab-content expanded">
                    <div class="tab-pane active" id="specs-tab">
                        <div id="specs-container">
                            <div class="loading">Loading specifications...</div>
            </div>
                    </div>
                    <div class="tab-pane" id="research-tab">
                        <div id="research-container">
                            <div class="loading">Loading market research...</div>
                </div>
                    </div>
                    <div class="tab-pane" id="tasks-tab">
                        <div id="tasks-container">
                    <div class="loading">Loading tasks...</div>
                </div>
            </div>
                    <div class="tab-pane" id="notes-tab">
                        <div id="notes-container">
                            <div class="loading">Loading notes...</div>
                    </div>
                </div>
                    <div class="tab-pane" id="milestones-tab">
                        <div id="milestones-timeline" class="milestones-timeline">
                    <div class="loading">Loading milestones...</div>
                </div>
            </div>
                    <div class="tab-pane" id="features-tab">
                        <div id="features-container">
                            <div class="loading">Loading features...</div>
        </div>
                </div>
                    <div class="tab-pane" id="expenses-tab">
                        <div id="expenses-container">
                            <div class="loading">Loading expenses...</div>
            </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="error-message" class="alert alert-danger" style="display: none;"></div>
        <div id="success-message" class="alert alert-success" style="display: none;"></div>
    </main>


    <script src="/assets/js/script.js"></script>
    <script src="/assets/js/mobile-optimizations.js"></script>

    <!-- App Dashboard Script -->
    <script type="module">
        // Import Firebase SDK
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { 
            signOut, 
            onAuthStateChanged,
            getAuth
        } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

        import { 
            collection, 
            addDoc, 
            getDocs, 
            query, 
            where, 
            orderBy, 
            serverTimestamp,
            getFirestore,
            doc,
            getDoc,
            updateDoc,
            deleteDoc
        } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyB9hr0IWM4EREzkKDxBxYoYinV6LJXWXV4",
            authDomain: "specify-ai.firebaseapp.com",
            projectId: "specify-ai",
            storageBucket: "specify-ai.firebasestorage.app",
            messagingSenderId: "734278787482",
            appId: "1:734278787482:web:0e312fb6f197e849695a23",
            measurementId: "G-4YR9LK63MR"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let currentUser = null;
        let currentApp = null;
        let appId = null;

        // Get app ID from URL
        function getAppIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('id');
        }

        // Auth state change handler
        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                appId = getAppIdFromUrl();
                if (appId) {
                    loadAppData();
                } else {
                    showError('No app ID provided');
                }
                updateAuthUI(user);
            } else {
                // Redirect to login if not authenticated
                window.location.href = '../index.html';
            }
        });

        // Load app data
        async function loadAppData() {
            if (!currentUser || !appId) return;
            
            try {
                // Load app details
                const appDoc = await getDoc(doc(db, 'apps', appId));
                if (appDoc.exists()) {
                    currentApp = { id: appDoc.id, ...appDoc.data() };
                    updateAppHeader();
                } else {
                    showError('App not found');
                    return;
                }

                // Load all related data
                await Promise.all([
                    loadAppSpecs(),
                    loadAppResearch(),
                    loadAppTasks(),
                    loadAppMilestones(),
                    loadAppNotes(),
                    loadAppFeatures(),
                    loadAppExpenses()
                ]);
                
                // Update stats after all data is loaded and rendered to DOM
                setTimeout(() => {
                    updateAllStats();
                }, 1000);

            } catch (error) {
                console.error('Error loading app data:', error);
                showError('Failed to load app data');
            }
        }

        // Update app header
        function updateAppHeader() {
            if (!currentApp) return;
            
            document.getElementById('app-name').textContent = currentApp.name;
            // Budget will be updated by updateDashboardCounters after data loads
        }

        // Load app specifications
        async function loadAppSpecs() {
            if (!currentApp || !currentApp.linkedSpecs) return;
            
            try {
                const specs = [];
                for (const specId of currentApp.linkedSpecs) {
                    const specDoc = await getDoc(doc(db, 'specs', specId));
                    if (specDoc.exists()) {
                        specs.push({ id: specDoc.id, ...specDoc.data() });
                    }
                }
                
                renderSpecs(specs);
            } catch (error) {
                console.error('Error loading specs:', error);
            }
        }

        // Load app market research
        async function loadAppResearch() {
            console.log('Loading app research...', currentApp);
            
            if (!currentApp || !currentApp.linkedResearch) {
                console.log('No linked research found');
                document.getElementById('research-count').textContent = '0';
                renderResearch([]);
                return;
            }
            
            console.log('Linked research IDs:', currentApp.linkedResearch);
            
            try {
                const research = [];
                for (const researchId of currentApp.linkedResearch) {
                    console.log('Loading research ID:', researchId);
                    
                    try {
                        // Try to load from marketResearch collection first
                        let researchDoc = await getDoc(doc(db, 'marketResearch', researchId));
                        
                        if (!researchDoc.exists()) {
                            console.log('Not found in marketResearch, trying specs collection');
                            // If not found, try specs collection with mode: "market"
                            researchDoc = await getDoc(doc(db, 'specs', researchId));
                        }
                        
                        if (researchDoc.exists()) {
                            console.log('Research found:', researchDoc.data());
                            research.push({ id: researchDoc.id, ...researchDoc.data() });
                        } else {
                            console.log('Research not found for ID:', researchId);
                        }
                    } catch (permissionError) {
                        console.warn('Permission denied for research ID:', researchId, permissionError);
                        // Skip this research item and continue with others
                        continue;
                    }
                }
                
                console.log('Total research loaded:', research.length);
                renderResearch(research);
            } catch (error) {
                console.error('Error loading research:', error);
                renderResearch([]);
            }
        }

        // Load app tasks
        async function loadAppTasks() {
            if (!currentUser || !appId) return;
            
            try {
                // Load tasks from Firestore (temporary simple query)
                const tasksQuery = query(
                    collection(db, 'appTasks'),
                    where('userId', '==', currentUser.uid),
                    where('appId', '==', appId)
                );
                
                const querySnapshot = await getDocs(tasksQuery);
                const tasks = [];
                querySnapshot.forEach((doc) => {
                    tasks.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });

                console.log('Loaded tasks from Firebase:', tasks);
                console.log('Number of tasks found:', tasks.length);
                console.log('Current user ID:', currentUser.uid);
                console.log('Current app ID:', appId);
                
                renderTasks(tasks);
                
            } catch (error) {
                console.error('Error loading tasks:', error);
                console.error('Detailed error:', error.message);
                alert('Error loading tasks. Check console for Firebase index links.');
                // Fallback to sample data if there's an error
                const sampleTasks = [
                    {
                        id: 'task_1',
                        title: 'Implement User Authentication',
                        description: 'Set up Firebase Auth with email/password and Google sign-in',
                        priority: 'high',
                        status: 'in-progress',
                        category: 'Backend',
                        dueDate: '2024-01-15',
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'task_2',
                        title: 'Design Dashboard Layout',
                        description: 'Create responsive dashboard with dark mode support',
                        priority: 'medium',
                        status: 'done',
                        category: 'Frontend',
                        dueDate: '2024-01-10',
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'task_3',
                        title: 'Add Task Management',
                        description: 'Implement CRUD operations for task management',
                        priority: 'high',
                        status: 'todo',
                        category: 'Frontend',
                        dueDate: '2024-01-20',
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'task_4',
                        title: 'Setup Database Schema',
                        description: 'Design Firestore collections and security rules',
                        priority: 'medium',
                        status: 'done',
                        category: 'Backend',
                        dueDate: '2024-01-05',
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'task_5',
                        title: 'Write Unit Tests',
                        description: 'Add comprehensive test coverage for core features',
                        priority: 'low',
                        status: 'todo',
                        category: 'Testing',
                        dueDate: '2024-01-25',
                        createdAt: new Date().toISOString()
                    }
                ];
                
                // Tasks count will be updated by the main stats function
                renderTasks(sampleTasks);
            }
        }

        // Load app milestones
        async function loadAppMilestones() {
            if (!currentUser || !appId) return;
            
            try {
                // Load milestones from Firestore
                const milestonesQuery = query(
                    collection(db, 'appMilestones'),
                    where('userId', '==', currentUser.uid),
                    where('appId', '==', appId),
                    orderBy('createdAt', 'desc')
                );
                
                const querySnapshot = await getDocs(milestonesQuery);
                const milestones = [];
                querySnapshot.forEach((doc) => {
                    milestones.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });

                renderMilestones(milestones);
                
            } catch (error) {
                console.error('Error loading milestones:', error);
                // Fallback to sample data if there's an error
                const sampleMilestones = [
                    {
                        id: 'milestone_1',
                        title: 'MVP Launch',
                        description: 'Complete core features and launch the first version',
                        dueDate: '2024-02-01',
                        progress: 75,
                        status: 'in-progress',
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'milestone_2',
                        title: 'User Authentication',
                        description: 'Implement secure user login and registration',
                        dueDate: '2024-01-15',
                        progress: 100,
                        status: 'completed',
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'milestone_3',
                        title: 'Dashboard Implementation',
                        description: 'Create main dashboard with all management features',
                        dueDate: '2024-01-25',
                        progress: 60,
                        status: 'in-progress',
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'milestone_4',
                        title: 'Database Setup',
                        description: 'Design and implement Firestore database schema',
                        dueDate: '2024-01-10',
                        progress: 100,
                        status: 'completed',
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'milestone_5',
                        title: 'Testing & QA',
                        description: 'Complete testing and quality assurance',
                        dueDate: '2024-02-10',
                        progress: 20,
                        status: 'in-progress',
                        createdAt: new Date().toISOString()
                    }
                ];
                
                // Milestones count will be updated by the main stats function
                renderMilestones(sampleMilestones);
            }
        }

        // Load app notes
        async function loadAppNotes() {
            if (!currentUser || !appId) return;
            
            try {
                // Load notes from Firestore (temporary simple query)
                const notesQuery = query(
                    collection(db, 'appNotes'),
                    where('userId', '==', currentUser.uid),
                    where('appId', '==', appId)
                );
                
                const querySnapshot = await getDocs(notesQuery);
                const notes = [];
                querySnapshot.forEach((doc) => {
                    notes.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });

                console.log('Loaded notes from Firebase:', notes);
                console.log('Number of notes found:', notes.length);
                
                renderNotes(notes);
                
            } catch (error) {
                console.error('Error loading notes:', error);
                console.error('Detailed error:', error.message);
                alert('Error loading notes. Check console for Firebase index links.');
                // Fallback to sample data if there's an error
                const sampleNotes = [
                    {
                        id: 'note_1',
                        content: 'Consider implementing lazy loading for the dashboard to improve initial load performance. The current implementation loads all data at once which can be slow for large datasets.',
                        category: 'performance',
                        tags: ['performance', 'optimization', 'lazy-loading'],
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'note_2',
                        content: 'Bug: The dark mode toggle sometimes doesn\'t persist across page refreshes. Need to check localStorage implementation.',
                        category: 'bugs',
                        tags: ['bug', 'dark-mode', 'localStorage'],
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'note_3',
                        content: 'Idea: Add a quick action toolbar for common tasks like creating new tasks, milestones, etc. This would improve user workflow efficiency.',
                        category: 'ideas',
                        tags: ['idea', 'ui-ux', 'workflow'],
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'note_4',
                        content: 'Architecture: The current modal system could be refactored into a reusable component. Consider creating a ModalManager class.',
                        category: 'architecture',
                        tags: ['architecture', 'refactor', 'modal'],
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'note_5',
                        content: 'Security: Need to implement proper input validation and sanitization for all user inputs, especially in the notes and task descriptions.',
                        category: 'security',
                        tags: ['security', 'validation', 'sanitization'],
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'note_6',
                        content: 'Database: Consider adding indexes for frequently queried fields like userId and appId to improve query performance.',
                        category: 'database',
                        tags: ['database', 'indexes', 'performance'],
                        createdAt: new Date().toISOString()
                    }
                ];
                
                renderNotes(sampleNotes);
            }
        }

        // Load app features (with sample data for now)
        async function loadAppFeatures() {
            if (!currentUser || !appId) return;
            
            try {
                // Load features from Firestore
                const featuresQuery = query(
                    collection(db, 'appFeatures'),
                    where('userId', '==', currentUser.uid),
                    where('appId', '==', appId),
                    orderBy('createdAt', 'desc')
                );
                
                const querySnapshot = await getDocs(featuresQuery);
                const features = [];
                querySnapshot.forEach((doc) => {
                    features.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });

                renderFeatures(features);
                
            } catch (error) {
                console.error('Error loading features:', error);
                // Fallback to sample data if there's an error
                const sampleFeatures = [
                    {
                        id: 'feature_1',
                        title: 'User Authentication',
                        description: 'Implement secure user login and registration system',
                        version: 'v1.0',
                        status: 'completed',
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'feature_2',
                        title: 'Dashboard Interface',
                        description: 'Create main dashboard with app management features',
                        version: 'v1.0',
                        status: 'completed',
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'feature_3',
                        title: 'Task Management',
                        description: 'Add ability to create and manage development tasks',
                        version: 'v1.1',
                        status: 'in-development',
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'feature_4',
                        title: 'Milestone Tracking',
                        description: 'Track project milestones and progress',
                        version: 'v1.1',
                        status: 'planned',
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'feature_5',
                        title: 'Budget Tracking',
                        description: 'Monitor project expenses and budget usage',
                        version: 'v1.2',
                        status: 'planned',
                        createdAt: new Date().toISOString()
                    }
                ];
                
                renderFeatures(sampleFeatures);
            }
        }

        // Load app expenses (with sample data for now)
        async function loadAppExpenses() {
            if (!currentUser || !appId) {
                console.log('âš ï¸ Cannot load expenses: missing currentUser or appId');
                return;
            }
            
            console.log('ðŸ“Š Loading expenses for user:', currentUser.uid, 'app:', appId);
            
            try {
                // Load expenses from Firestore
                const expensesQuery = query(
                    collection(db, 'appExpenses'),
                    where('userId', '==', currentUser.uid),
                    where('appId', '==', appId),
                    orderBy('createdAt', 'desc')
                );
                
                const querySnapshot = await getDocs(expensesQuery);
                const expenses = [];
                querySnapshot.forEach((doc) => {
                    expenses.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });

                console.log('âœ… Found', expenses.length, 'expenses from Firebase');
                renderExpenses(expenses);
                
            } catch (error) {
                console.error('Error loading expenses:', error);
                
                // Check if it's a composite index error
                if (error.code === 'failed-precondition' && error.message.includes('index')) {
                    console.log('ðŸ“‹ Creating composite index for expenses. Loading without orderBy for now...');
                    
                    // Try loading without orderBy as fallback
                    try {
                        const simpleQuery = query(
                            collection(db, 'appExpenses'),
                            where('userId', '==', currentUser.uid),
                            where('appId', '==', appId)
                        );
                        
                        const querySnapshot = await getDocs(simpleQuery);
                        const expenses = [];
                        querySnapshot.forEach((doc) => {
                            expenses.push({
                                id: doc.id,
                                ...doc.data()
                            });
                        });

                        if (expenses.length > 0) {
                            console.log('âœ… Successfully loaded', expenses.length, 'expenses without orderBy');
                            renderExpenses(expenses);
                            return;
                        } else {
                            console.log('ðŸ“­ No expenses found in database');
                        }
                    } catch (secondError) {
                        console.error('Error with simple query:', secondError);
                    }
                }
                
                // Show message to user about sample data
                console.warn('ðŸš¨ Showing sample data because of Firebase error. Your real expenses will appear once the database index is ready.');
                
                // Fallback to sample data if there's an error
                const sampleExpenses = [
                    {
                        id: 'expense_1',
                        description: 'Firebase Hosting Plan',
                        amount: 25.00,
                        category: 'hosting',
                        date: '2024-01-15',
                        notes: 'Monthly hosting fee',
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'expense_2',
                        description: 'Figma Pro Subscription',
                        amount: 12.00,
                        category: 'tools',
                        date: '2024-01-10',
                        notes: 'Design tool subscription',
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'expense_3',
                        description: 'Domain Registration',
                        amount: 15.00,
                        category: 'hosting',
                        date: '2024-01-05',
                        notes: 'Annual domain renewal',
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'expense_4',
                        description: 'UI/UX Design Consultation',
                        amount: 200.00,
                        category: 'consulting',
                        date: '2024-01-20',
                        notes: 'Professional design review',
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: 'expense_5',
                        description: 'Marketing Campaign',
                        amount: 150.00,
                        category: 'marketing',
                        date: '2024-01-25',
                        notes: 'Social media advertising',
                        createdAt: new Date().toISOString()
                    }
                ];
                
                renderExpenses(sampleExpenses);
            }
        }

        // Render functions (simplified for now)
        function renderSpecs(specs) {
            const container = document.getElementById('specs-container');
            if (specs.length === 0) {
                container.innerHTML = '<div class="text-center text-muted">No specifications linked.</div>';
                return;
            }
             container.innerHTML = `
                 <div class="specs-grid">
                     ${specs.map(spec => `
                         <div class="spec-card" onclick="window.open('spec.html?id=${spec.id}', '_blank')">
                             <div class="card-header">
                                 <h4 class="card-title">${spec.title}</h4>
                                 <i class="fas fa-external-link-alt card-link-icon"></i>
                    </div>
                             <div class="card-meta">
                                 <span class="card-date">${new Date(spec.createdAt || Date.now()).toLocaleDateString()}</span>
                                 <span class="card-status">${spec.status || 'Draft'}</span>
                </div>
                         </div>
                     `).join('')}
                 </div>
             `;
        }

        function renderResearch(research) {
            const container = document.getElementById('research-container');
            if (!container) {
                console.error('Research container not found');
                return;
            }
            
            if (research.length === 0) {
                container.innerHTML = '<div class="text-center text-muted">No market research linked.</div>';
                return;
            }
            
             container.innerHTML = `
                 <div class="specs-grid">
                     ${research.map(researchItem => `
                         <div class="research-card" onclick="window.open('research.html?id=${researchItem.id}', '_blank')">
                             <div class="card-header">
                                 <h4 class="card-title">${researchItem.title || 'Untitled Research'}</h4>
                                 <i class="fas fa-external-link-alt card-link-icon"></i>
                    </div>
                             <div class="card-meta">
                                 <span class="card-date">${new Date(researchItem.createdAt || Date.now()).toLocaleDateString()}</span>
                                 <span class="card-type">${researchItem.type || 'Research'}</span>
                </div>
                         </div>
                     `).join('')}
                 </div>
             `;
        }

        function renderTasks(tasks) {
            const container = document.getElementById('tasks-container');
            if (tasks.length === 0) {
                container.innerHTML = '<div class="text-center text-muted">No tasks yet. Add your first task!</div>';
                return;
            }
            
            const tasksHTML = tasks.map(task => `
                <div class="note-item-simple">
                    <div class="note-header-simple">
                        <span class="note-category-simple ${task.status}" onclick="toggleTaskStatusSimple('${task.id}'); event.stopPropagation();">${task.status.replace('-', ' ').toUpperCase()}</span>
                        <span class="note-title-simple" onclick="showTaskDetails('${task.id}')">${task.title}</span>
                        <div class="note-meta-inline">
                            ${task.priority ? `<span class="note-priority ${task.priority.toLowerCase()}">${task.priority}</span>` : ''}
                            ${task.dueDate ? `<span>ðŸ“… ${new Date(task.dueDate).toLocaleDateString()}</span>` : ''}
                        </div>
                    </div>
                    <div class="note-details-simple" id="task-details-${task.id}" style="display: none;">
                        <div class="note-content-full">
                            <p><strong>Title:</strong> ${task.title}</p>
                            <p><strong>Description:</strong> ${task.description || 'No description'}</p>
                            <p><strong>Priority:</strong> ${task.priority}</p>
                            <p><strong>Category:</strong> ${task.category || 'General'}</p>
                            ${task.dueDate ? `<p><strong>Due Date:</strong> ${new Date(task.dueDate).toLocaleDateString()}</p>` : ''}
                        </div>
                        <div class="note-meta-simple">
                            <span class="note-date-simple">${new Date(task.createdAt).toLocaleDateString()}</span>
                        </div>
                        <div class="note-actions-simple">
                            <button onclick="toggleTaskStatusSimple('${task.id}')" title="Toggle Status">
                                <i class="fas fa-check"></i> Toggle Status
                            </button>
                            <button onclick="deleteTaskConfirm('${task.id}')" title="Delete" style="color: #dc3545;">
                                <i class="fas fa-trash"></i> Delete
                            </button>
                        </div>
                    </div>
                </div>
            `).join('');
            
            container.innerHTML = `<div class="tasks-list-simple">${tasksHTML}</div>`;
            
            // Counter will be updated by updateAllStats after all data loads
        }
        
        // Show task details on title click (using note style)
        window.showTaskDetails = function(taskId) {
            const details = document.getElementById(`task-details-${taskId}`);
            if (details) {
                const isVisible = details.style.display !== 'none';
                details.style.display = isVisible ? 'none' : 'block';
            }
        }
        
        // Toggle task status on status click
        window.toggleTaskStatusSimple = async function(taskId) {
            const taskItem = document.querySelector(`[onclick="showTaskDetails('${taskId}')"]`).closest('.note-item-simple');
            const statusBadge = taskItem.querySelector('.note-category-simple');
            
            // Cycle through statuses: to-do -> in-progress -> done -> to-do
            const currentText = statusBadge.textContent.toLowerCase();
            let newStatus = '';
            
            if (currentText.includes('to do') || currentText.includes('to-do')) {
                newStatus = 'in-progress';
                statusBadge.textContent = 'IN PROGRESS';
                statusBadge.className = 'note-category-simple in-progress';
            } else if (currentText.includes('progress')) {
                newStatus = 'done';
                statusBadge.textContent = 'DONE';
                statusBadge.className = 'note-category-simple done';
            } else {
                newStatus = 'to-do';
                statusBadge.textContent = 'TO DO';
                statusBadge.className = 'note-category-simple to-do';
            }
            
            // Update in Firebase
            try {
                const taskRef = doc(db, 'appTasks', taskId);
                await updateDoc(taskRef, {
                    status: newStatus,
                    updatedAt: new Date().toISOString()
                });
                showSuccess(`Task status updated to ${newStatus.replace('-', ' ')}!`);
            } catch (error) {
                console.error('Error updating task status:', error);
                showError('Failed to update task status');
            }
        }

        function renderMilestones(milestones) {
            const container = document.getElementById('milestones-timeline');
            if (milestones.length === 0) {
                container.innerHTML = '<div class="text-center text-muted">No milestones yet. Add your first milestone!</div>';
                return;
            }
            
            // Sort milestones by order (for setup milestones) or by date (for legacy milestones)
            const sortedMilestones = [...milestones].sort((a, b) => {
                if (a.order !== undefined && b.order !== undefined) {
                    return a.order - b.order;
                }
                return new Date(a.dueDate || a.targetDate) - new Date(b.dueDate || b.targetDate);
            });
            
            // Calculate progress
            const completedCount = sortedMilestones.filter(m => m.status === 'completed').length;
            const progressPercentage = (completedCount / sortedMilestones.length) * 100;
            
            // Generate timeline points with sequential logic
            const timelinePoints = sortedMilestones.map((milestone, index) => {
                let status = 'planned';
                let isClickable = false;
                let clickHandler = '';
                let cursorStyle = '';
                let title = '';
                
                if (milestone.status === 'completed') {
                    status = 'completed';
                    isClickable = true;
                    clickHandler = `onclick="toggleMilestoneStatus('${milestone.id}')"`;
                    title = 'Click to mark as incomplete';
                } else if (milestone.status === 'in-progress') {
                    status = 'current';
                    isClickable = true;
                    clickHandler = `onclick="toggleMilestoneStatus('${milestone.id}')"`;
                    title = 'Click to complete this milestone';
                } else {
                    // Check if this milestone can be activated (previous one is completed)
                    const prevMilestone = index > 0 ? sortedMilestones[index - 1] : null;
                    const canActivate = index === 0 || (prevMilestone && prevMilestone.status === 'completed');
                    
                    if (canActivate) {
                        status = 'planned';
                        isClickable = true;
                        clickHandler = `onclick="toggleMilestoneStatus('${milestone.id}')"`;
                        title = 'Click to start this milestone';
                    } else {
                        status = 'locked';
                        isClickable = false;
                        title = 'Complete previous milestone first';
                        cursorStyle = 'style="cursor: not-allowed;"';
                    }
                }
                
                 return `
                     <div class="milestone-container" data-milestone-id="${milestone.id}">
                         <div class="milestone-point ${status}" 
                              ${clickHandler}
                              onmouseover="showMilestoneInfo('${milestone.id}')"
                              title="${title}"
                              ${cursorStyle}>
                         </div>
                         <div class="milestone-label">${milestone.title}</div>
                     </div>
                 `;
            }).join('');
            
            // Find current milestone (in-progress or most recent)
            const currentMilestone = sortedMilestones.find(m => m.status === 'in-progress') || 
                                   sortedMilestones.find(m => m.status === 'completed') || 
                                   sortedMilestones[0];
            
            // Create percentages bar above timeline
            const percentagesBar = sortedMilestones.map((milestone, index) => {
                let status = 'planned';
                if (milestone.status === 'completed') {
                    status = 'completed';
                } else if (milestone.status === 'in-progress') {
                    status = 'current';
                } else {
                    const prevMilestone = index > 0 ? sortedMilestones[index - 1] : null;
                    const canActivate = index === 0 || (prevMilestone && prevMilestone.status === 'completed');
                    status = canActivate ? 'planned' : 'locked';
                }
                
                return `<div class="milestone-percentage-above ${status}">${milestone.progress}%</div>`;
            }).join('');

            container.innerHTML = `
                <div class="timeline-container">
                    <div class="milestone-percentages-bar">
                        ${percentagesBar}
                    </div>
                    <div class="timeline-bar">
                        <div class="timeline-progress" style="width: ${progressPercentage}%"></div>
                </div>
                    <div class="timeline-milestones">
                        ${timelinePoints}
                    </div>
                    <div class="milestone-info-panel" id="milestone-info-panel">
                        ${currentMilestone ? `
                            <div class="milestone-info-title">${currentMilestone.title}</div>
                            <div class="milestone-info-description">${currentMilestone.description || 'No description available'}</div>
                            <div class="milestone-info-meta">
                                <span class="milestone-info-date">Due: ${new Date(currentMilestone.dueDate).toLocaleDateString()}</span>
                                <span class="milestone-info-progress">${currentMilestone.progress}% Complete</span>
                            </div>
                        ` : `
                            <div class="milestone-info-title">No milestones</div>
                            <div class="milestone-info-description">Add your first milestone to track project progress.</div>
                        `}
                    </div>
                </div>
            `;

            // Store milestones data for showMilestoneInfo function
            window.milestonesData = {};
            sortedMilestones.forEach(milestone => {
                window.milestonesData[milestone.id] = milestone;
            });
            
            // Counter will be updated by updateAllStats after all data loads
        }
        
        // Toggle milestone status (planned -> in-progress -> completed -> planned)
        window.toggleMilestoneStatus = async function(milestoneId) {
            try {
                // Find the milestone in our data
                const milestone = window.milestonesData[milestoneId];
                if (!milestone) {
                    console.error('Milestone not found:', milestoneId);
                    return;
                }

                // Determine next status
                let newStatus;
                switch(milestone.status) {
                    case 'planned':
                        newStatus = 'in-progress';
                        break;
                    case 'in-progress':
                        newStatus = 'completed';
                        break;
                    case 'completed':
                        newStatus = 'planned';
                        break;
                    default:
                        newStatus = 'in-progress';
                }

                // Update in Firebase
                await updateDoc(doc(db, 'appMilestones', milestoneId), {
                    status: newStatus
                });

                // Update local data
                milestone.status = newStatus;

                // Reload milestones to update display
                loadAppMilestones();

                // Show success message
                const statusText = newStatus === 'completed' ? 'completed' : 
                                 newStatus === 'in-progress' ? 'in progress' : 'planned';
                showSuccess(`Milestone marked as ${statusText}!`);

            } catch (error) {
                console.error('Error updating milestone status:', error);
                alert('Error updating milestone status: ' + error.message);
            }
        }

        // Show milestone info in panel
        window.showMilestoneInfo = function(milestoneId) {
            const milestone = window.milestonesData[milestoneId];
            if (!milestone) return;

            const panel = document.getElementById('milestone-info-panel');
            if (panel) {
                panel.innerHTML = `
                    <div class="milestone-info-title">${milestone.title}</div>
                    <div class="milestone-info-description">${milestone.description || 'No description available'}</div>
                    <div class="milestone-info-meta">
                        <span class="milestone-info-date">Due: ${new Date(milestone.dueDate).toLocaleDateString()}</span>
                        <span class="milestone-info-progress">${milestone.progress}% Complete</span>
                    </div>
                `;
            }
        }

        // Show milestone details on click (legacy function)
        window.showMilestoneDetails = function(milestoneId) {
            showMilestoneInfo(milestoneId);
            document.querySelectorAll('.milestone-details').forEach(detail => {
                detail.classList.remove('active');
            });
            
            // Show selected milestone details
            const selectedDetail = document.getElementById(`details-${milestoneId}`);
            if (selectedDetail) {
                selectedDetail.classList.add('active');
            }
        }

        function renderNotes(notes) {
            const container = document.getElementById('notes-container');
            
            // Define 10 fixed categories
            const categories = [
                { key: 'bugs', name: 'Bugs', icon: 'fas fa-bug' },
                { key: 'ideas', name: 'Ideas', icon: 'fas fa-lightbulb' },
                { key: 'architecture', name: 'Architecture', icon: 'fas fa-sitemap' },
                { key: 'performance', name: 'Performance', icon: 'fas fa-tachometer-alt' },
                { key: 'security', name: 'Security', icon: 'fas fa-shield-alt' },
                { key: 'features', name: 'Features', icon: 'fas fa-star' },
                { key: 'ui', name: 'UI/UX', icon: 'fas fa-palette' },
                { key: 'database', name: 'Database', icon: 'fas fa-database' },
                { key: 'api', name: 'API', icon: 'fas fa-code' },
                { key: 'testing', name: 'Testing', icon: 'fas fa-vial' }
            ];
            
            // Group notes by category
            const groupedNotes = {};
            notes.forEach(note => {
                const category = note.category || 'uncategorized';
                if (!groupedNotes[category]) {
                    groupedNotes[category] = [];
                }
                groupedNotes[category].push(note);
            });
            
            const categoryHTML = categories.map(category => {
                const categoryNotes = groupedNotes[category.key] || [];
                const notesHTML = categoryNotes.map(note => `
                    <div class="note-card" data-note-id="${note.id}" onclick="showNoteDetails('${note.id}')">
                        <div class="note-card-meta">
                            <span>${new Date(note.createdAt).toLocaleDateString()}</span>
                        </div>
                        <div class="note-card-content">
                            ${note.content.length > 100 ? note.content.substring(0, 100) + '...' : note.content}
                        </div>
                        ${note.tags && note.tags.length > 0 ? `
                            <div class="note-card-tags">
                                ${note.tags.slice(0, 3).map(tag => `<span class="note-tag">${tag}</span>`).join('')}
                            </div>
                        ` : ''}
                        <div class="note-card-actions" onclick="event.stopPropagation()">
                            <button class="note-card-btn" onclick="deleteNoteConfirm('${note.id}')" title="Delete">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `).join('');
                
                const emptyState = categoryNotes.length === 0 ? 
                    `<div class="category-empty">No notes in this category yet</div>` : '';
                
                return `
                    <div class="notes-category-group">
                        <div class="category-header">
                            <div class="category-title">
                                <i class="${category.icon}"></i>
                                ${category.name}
                                <span class="category-count">${categoryNotes.length}</span>
                            </div>
                            <div class="category-actions">
                                <button class="category-btn" onclick="addNoteToCategory('${category.key}')" title="Add note to this category">
                                    <i class="fas fa-plus"></i> Add Note
                                </button>
                            </div>
                        </div>
                        <div class="category-notes">
                            ${categoryNotes.length > 0 ? notesHTML : emptyState}
                        </div>
                    </div>
                `;
            }).join('');
            
            container.innerHTML = `<div class="notes-list-simple">${categoryHTML}</div>`;
            
            // Counter will be updated by updateAllStats after all data loads
        }

        function getCategoryIcon(category) {
            const icons = {
                'bugs': 'fas fa-bug',
                'ideas': 'fas fa-lightbulb',
                'architecture': 'fas fa-sitemap',
                'performance': 'fas fa-tachometer-alt',
                'security': 'fas fa-shield-alt',
                'features': 'fas fa-star',
                'ui': 'fas fa-palette',
                'database': 'fas fa-database',
                'api': 'fas fa-code',
                'testing': 'fas fa-vial',
                'uncategorized': 'fas fa-sticky-note'
            };
            return icons[category] || 'fas fa-sticky-note';
        }
        
        // Show note details on title click
        window.showNoteDetails = function(noteId) {
            const details = document.getElementById(`note-details-${noteId}`);
            if (details) {
                const isVisible = details.style.display !== 'none';
                details.style.display = isVisible ? 'none' : 'block';
            }
        }

        function renderFeatures(features) {
            const container = document.getElementById('features-container');
            if (features.length === 0) {
                container.innerHTML = '<div class="text-center text-muted">No versions yet. Add your first version!</div>';
                return;
            }

            // Now features are actually version documents, each containing a features array
            const featuresByVersion = {};
            features.forEach(versionDoc => {
                const version = versionDoc.version;
                const versionFeatures = versionDoc.features || [];
                
                // Convert features array to the expected format
                const formattedFeatures = versionFeatures.map((feature, index) => ({
                    id: `${versionDoc.id}-feature-${index}`,
                    title: feature.title,
                    status: feature.status || 'planned',
                    description: feature.description || feature.title
                }));
                
                featuresByVersion[version] = formattedFeatures;
            });

             // Sort versions chronologically (newest first, oldest at bottom)
             const sortedVersions = Object.keys(featuresByVersion).sort((a, b) => {
                 const aNum = parseFloat(a.replace('v', ''));
                 const bNum = parseFloat(b.replace('v', ''));
                 return bNum - aNum; // Newest first, oldest at bottom
             });

            const featureListHTML = sortedVersions.map(version => {
                const versionFeatures = featuresByVersion[version];
                const completedFeatures = versionFeatures.filter(f => f.status === 'completed').length;
                const totalFeatures = versionFeatures.length;
                const progress = totalFeatures > 0 ? Math.round((completedFeatures / totalFeatures) * 100) : 0;
                
                // Determine version status
                let versionStatus = 'planning';
                if (progress === 100) versionStatus = 'completed';
                else if (progress > 0) versionStatus = 'in-progress';
                
                return `
                    <div class="version-roadmap-item ${versionStatus}" data-version="${version}">
                        <div class="version-header" onclick="toggleVersionDetails('${version}')">
                            <div class="version-info">
                                <span class="version-name">${version}</span>
                                <span class="version-progress-text">${completedFeatures}/${totalFeatures} features</span>
                            </div>
                            <div class="version-actions">
                                <div class="version-status-badge ${versionStatus}">
                                    ${versionStatus === 'completed' ? 'Released' : versionStatus === 'in-progress' ? 'Active' : 'Planned'}
                                </div>
                                <button class="delete-version-btn" onclick="deleteVersionConfirm('${version}'); event.stopPropagation();" title="Delete Version">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                        <div class="version-progress-bar">
                            <div class="version-progress-fill" style="width: ${progress}%"></div>
                        </div>
                        <div class="version-features-details" id="version-${version}" style="display: none;">
                            ${versionFeatures.map(feature => `
                                <div class="feature-item-roadmap" data-feature-id="${feature.id}">
                                    <div class="feature-status-circle ${feature.status}" onclick="toggleFeatureStatus('${feature.id}', '${version}')" title="Click to change status">
                                    </div>
                                    <div class="feature-content-roadmap">
                                        <div class="feature-title-roadmap">${feature.title}</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `<div class="features-roadmap">${featureListHTML}</div>`;
            
            // Counter will be updated by updateAllStats after all data loads
        }
        
        // Toggle version details
        window.toggleVersionDetails = function(version) {
            const details = document.getElementById(`version-${version}`);
            if (details) {
                const isVisible = details.style.display !== 'none';
                details.style.display = isVisible ? 'none' : 'block';
            }
        }

        function renderExpenses(expenses) {
            const container = document.getElementById('expenses-container');
            if (expenses.length === 0) {
                container.innerHTML = '<div class="text-center text-muted">No expenses yet. Add your first expense!</div>';
                return;
            }
            
            // Sort expenses by date (newest first)
            const sortedExpenses = expenses.sort((a, b) => new Date(b.date) - new Date(a.date));
            
            // Calculate monthly summary
            const currentMonth = new Date().getMonth();
            const currentYear = new Date().getFullYear();
            const thisMonthExpenses = sortedExpenses.filter(expense => {
                const expenseDate = new Date(expense.date);
                return expenseDate.getMonth() === currentMonth && expenseDate.getFullYear() === currentYear;
            });
            const thisMonthTotal = thisMonthExpenses.reduce((sum, expense) => sum + expense.amount, 0);
            
            // Group by categories for this month
            const categorySummary = {};
            thisMonthExpenses.forEach(expense => {
                if (!categorySummary[expense.category]) {
                    categorySummary[expense.category] = 0;
                }
                categorySummary[expense.category] += expense.amount;
            });
            
            const expensesSummaryHTML = `
                <div class="expenses-summary">
                    <div class="summary-title">This Month: $${thisMonthTotal.toFixed(2)}</div>
                    <div class="summary-categories">
                        ${Object.entries(categorySummary).map(([cat, amount]) => 
                            `<span class="category-chip ${cat}">$${amount.toFixed(2)} ${cat}</span>`
                        ).join('')}
                    </div>
                </div>
            `;
            
            const expensesHTML = sortedExpenses.map(expense => `
                <div class="expense-item-simple" data-expense-id="${expense.id}" onclick="showExpenseDetails('${expense.id}')">
                    <div class="expense-summary">
                        <span class="expense-amount-simple">$${expense.amount.toFixed(2)}</span>
                        <span class="expense-description-simple">${expense.description}</span>
                        <span class="expense-date-simple">${new Date(expense.date).toLocaleDateString()}</span>
                        ${expense.frequency && expense.frequency !== 'one-time' ? 
                            `<span class="expense-frequency-badge ${expense.frequency}">${expense.frequency}</span>` : 
                            ''
                        }
                    </div>
                    <div class="expense-details-simple" id="expense-details-${expense.id}" style="display: none;">
                        <div class="expense-category-detail ${expense.category}">${expense.category.toUpperCase()}</div>
                        ${expense.frequency ? `<div class="expense-frequency-detail">Frequency: ${expense.frequency}</div>` : ''}
                        ${expense.notes ? `<div class="expense-notes-detail">${expense.notes}</div>` : ''}
                        <div class="expense-actions-simple">
                            <button onclick="deleteExpenseConfirm('${expense.id}'); event.stopPropagation();" title="Delete" style="color: #dc3545;">
                                <i class="fas fa-trash"></i> Delete
                            </button>
                        </div>
                    </div>
                </div>
            `).join('');
            
            container.innerHTML = `
                <div class="expenses-tracker">
                    ${expensesSummaryHTML}
                    <div class="expenses-list-simple">
                        ${expensesHTML}
                    </div>
                </div>
            `;
            
            // Counter will be updated by updateAllStats after all data loads
        }
        
        // Show expense details on click
        window.showExpenseDetails = function(expenseId) {
            const details = document.getElementById(`expense-details-${expenseId}`);
            if (details) {
                const isVisible = details.style.display !== 'none';
                details.style.display = isVisible ? 'none' : 'block';
            }
        }

        // Unified Tab Management Function
        window.switchUnifiedTab = function(tabName) {
            // Update tab buttons (unified dashboard only)
            document.querySelectorAll('.unified-dashboard [data-tab]').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.unified-dashboard [data-tab="${tabName}"]`).classList.add('active');

            // Update tab panes (unified dashboard only)
            document.querySelectorAll('.unified-dashboard .tab-pane').forEach(pane => {
                pane.classList.remove('active');
            });
            document.getElementById(`${tabName}-tab`).classList.add('active');

            // Update tab actions with minimalist plus button
            const actionsContainer = document.getElementById('unified-tab-actions');
            
            switch(tabName) {
                case 'specs':
                    actionsContainer.innerHTML = `
                        <div class="action-buttons">
                            <button class="plus-button" onclick="redirectToSpecsCreator()" title="Create New Specification">+</button>
                        </div>
                    `;
                    break;
                case 'research':
                    actionsContainer.innerHTML = `
                        <div class="action-buttons">
                            <button class="plus-button" onclick="redirectToResearchCreator()" title="Create New Research">+</button>
                        </div>
                    `;
                    break;
                case 'tasks':
                    actionsContainer.innerHTML = `
                        <div class="action-buttons">
                            <button class="plus-button" onclick="openTaskModal()" title="Add New Task">+</button>
                        </div>
                    `;
                    break;
                case 'notes':
                    actionsContainer.innerHTML = `
                        <div class="action-buttons">
                            <!-- Plus buttons are now in each category -->
                        </div>
                    `;
                    break;
                case 'milestones':
                    // Check if milestones already exist
                    checkMilestonesExistence().then(exists => {
                        if (exists) {
                            actionsContainer.innerHTML = `
                                <div class="action-buttons">
                                    <button class="plus-button delete-mode" onclick="deleteAllMilestonesConfirm()" title="Delete All Milestones">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            `;
                        } else {
                            actionsContainer.innerHTML = `
                                <div class="action-buttons">
                                    <button class="plus-button" onclick="openMilestonesSetupModal()" title="Setup Milestones">+</button>
                                </div>
                            `;
                        }
                    });
                    break;
                case 'features':
                    actionsContainer.innerHTML = `
                        <div class="action-buttons">
                            <button class="plus-button" onclick="openFeatureModal()" title="Add New Feature">+</button>
                        </div>
                    `;
                    break;
                case 'expenses':
                    actionsContainer.innerHTML = `
                        <div class="action-buttons">
                            <button class="plus-button" onclick="openExpenseModal()" title="Add New Expense">+</button>
                        </div>
                    `;
                    break;
                default:
                    actionsContainer.innerHTML = '';
            }
        }

        // Legacy function support (for backward compatibility)
        window.switchTab = function(tabName) {
            switchUnifiedTab(tabName);
        }

        window.switchWorkTab = function(tabName) {
            switchUnifiedTab(tabName);
        }

        // Redirect functions for specs and research
        window.redirectToSpecsCreator = function() {
            window.open('../processing-unified.html', '_blank');
        }

        window.redirectToResearchCreator = function() {
            window.open('../processing-unified.html', '_blank');
        }

        // Modal functions for other tabs
        window.openTaskModal = function() {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content minimal">
                    <div class="modal-header">
                        <h3>Add New Task</h3>
                        <button class="modal-close" onclick="closeModal()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <form id="task-form">
                            <div class="form-group">
                                <label>Title</label>
                                <input type="text" id="task-title" placeholder="Enter task title" required>
                            </div>
                            <div class="form-group">
                                <label>Description</label>
                                <textarea id="task-description" placeholder="Enter task description"></textarea>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Priority</label>
                                    <select id="task-priority">
                                        <option value="low">Low</option>
                                        <option value="medium" selected>Medium</option>
                                        <option value="high">High</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Status</label>
                                    <select id="task-status">
                                        <option value="to-do">To Do</option>
                                        <option value="in-progress">In Progress</option>
                                        <option value="done">Done</option>
                                    </select>
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Due Date</label>
                                    <input type="date" id="task-due-date">
                                </div>
                                <div class="form-group">
                                    <label>Created Date</label>
                                    <input type="date" id="task-created-date" value="${new Date().toISOString().split('T')[0]}" readonly>
                                </div>
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="submitTask()">Add Task</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        window.addNoteToCategory = function(category) {
            openNoteModal(category);
        }

        window.openNoteModal = function(preselectedCategory = null) {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content minimal">
                    <div class="modal-header">
                        <h3>Add New Note</h3>
                        <button class="modal-close" onclick="closeModal()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <form id="note-form">
                            <div class="form-group">
                                <label>Category</label>
                                <select id="note-category">
                                    <option value="bugs" ${preselectedCategory === 'bugs' ? 'selected' : ''}>ðŸ› Bugs</option>
                                    <option value="ideas" ${preselectedCategory === 'ideas' ? 'selected' : ''}>ðŸ’¡ Ideas</option>
                                    <option value="architecture" ${preselectedCategory === 'architecture' ? 'selected' : ''}>ðŸ—ï¸ Architecture</option>
                                    <option value="performance" ${preselectedCategory === 'performance' ? 'selected' : ''}>âš¡ Performance</option>
                                    <option value="security" ${preselectedCategory === 'security' ? 'selected' : ''}>ðŸ”’ Security</option>
                                    <option value="features" ${preselectedCategory === 'features' ? 'selected' : ''}>â­ Features</option>
                                    <option value="ui" ${preselectedCategory === 'ui' ? 'selected' : ''}>ðŸŽ¨ UI/UX</option>
                                    <option value="database" ${preselectedCategory === 'database' ? 'selected' : ''}>ðŸ—„ï¸ Database</option>
                                    <option value="api" ${preselectedCategory === 'api' ? 'selected' : ''}>ðŸ”Œ API</option>
                                    <option value="testing" ${preselectedCategory === 'testing' ? 'selected' : ''}>ðŸ§ª Testing</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Content</label>
                                <textarea id="note-content" placeholder="Enter your note content" rows="4" required></textarea>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Tags (comma separated)</label>
                                    <input type="text" id="note-tags" placeholder="bug, urgent, frontend">
                                </div>
                                <div class="form-group">
                                    <label>Created Date</label>
                                    <input type="date" id="note-created-date" value="${new Date().toISOString().split('T')[0]}" readonly>
                                </div>
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="submitNote()">Add Note</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        window.openMilestonesSetupModal = function() {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>Setup Project Milestones</h3>
                        <button class="modal-close" onclick="closeModal()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label>How many milestones would you like to create?</label>
                            <div class="milestone-count-controls">
                                <input type="number" id="milestones-count" min="2" max="10" value="3" placeholder="Enter number of milestones">
                                <button type="button" class="btn btn-outline-primary" onclick="generateMilestoneInputs()" style="margin-left: 10px;">
                                    <i class="fas fa-refresh"></i> Update Templates
                                </button>
                            </div>
                        </div>
                        <div id="milestones-list">
                            <!-- Dynamic milestone inputs will be generated here -->
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="submitMilestonesSetup()">Create Milestones</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Generate initial milestone inputs with a small delay to ensure DOM is ready
            setTimeout(() => {
                generateMilestoneInputs();
            }, 100);
        }

        // Generate dynamic milestone inputs
        window.generateMilestoneInputs = function() {
            console.log('ðŸ”„ generateMilestoneInputs called');
            
            const countInput = document.getElementById('milestones-count');
            const container = document.getElementById('milestones-list');
            
            if (!countInput || !container) {
                console.error('âŒ Missing elements:', { 
                    countInput: !!countInput, 
                    container: !!container 
                });
                return;
            }
            
            // Debug: show what we're reading
            console.log('ðŸ“ countInput element:', countInput);
            console.log('ðŸ“ Input value:', countInput?.value);
            console.log('ðŸ“ All inputs in modal:', document.querySelectorAll('#milestones-count'));
            
            // Try to get the value more reliably
            let inputValue = countInput?.value;
            if (!inputValue) {
                // Try to find the input again
                const allNumberInputs = document.querySelectorAll('input[type="number"]');
                console.log('ðŸ” Found number inputs:', allNumberInputs.length);
                for (let input of allNumberInputs) {
                    if (input.min === "2" && input.max === "10") {
                        console.log('ðŸŽ¯ Found milestone count input:', input.value);
                        inputValue = input.value;
                        break;
                    }
                }
            }
            
            const count = parseInt(inputValue) || 3;
            console.log('ðŸ“Š Final parsed count:', count, 'milestone templates');
            
            // Ensure count is within valid range
            if (count < 2) {
                countInput.value = 2;
                return generateMilestoneInputs();
            }
            if (count > 10) {
                countInput.value = 10;
                return generateMilestoneInputs();
            }
            
            let inputsHTML = '';
            for (let i = 1; i <= count; i++) {
                const percentage = Math.round((i / count) * 100);
                inputsHTML += `
                    <div class="milestone-input">
                        <div class="milestone-input-header">
                            <h4>Milestone ${i} (${percentage}%)</h4>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Title *</label>
                                <input type="text" class="milestone-title" placeholder="e.g., MVP Launch, Beta Testing" required>
                            </div>
                            <div class="form-group">
                                <label>Target Date</label>
                                <input type="date" class="milestone-date">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Description</label>
                            <textarea class="milestone-description" placeholder="Describe what needs to be achieved at this milestone"></textarea>
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = inputsHTML;
            console.log('âœ… Successfully generated', count, 'milestone templates');
        }

        window.openFeatureModal = function() {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>Add New Version</h3>
                        <button class="modal-close" onclick="closeModal()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <form id="version-form">
                            <div class="form-group">
                                <label>Version Name *</label>
                                <input type="text" id="version-name" placeholder="e.g., v1.1, v2.0" required>
                            </div>
                            <div class="form-group">
                                <label>Features in this version *</label>
                                <div id="features-list">
                                    <div class="feature-input">
                                        <input type="text" class="feature-text" placeholder="Enter feature description" required>
                                        <button type="button" class="remove-feature" onclick="removeFeature(this)" style="display: none;">Ã—</button>
                                    </div>
                                </div>
                                <button type="button" class="btn btn-secondary" onclick="addFeatureInput()" style="margin-top: 10px;">
                                    <i class="fas fa-plus"></i> Add Another Feature
                                </button>
                            </div>
                            <div class="form-group">
                                <label>Version Status</label>
                                <select id="version-status">
                                    <option value="planned">Planned</option>
                                    <option value="in-progress">In Progress</option>
                                    <option value="completed">Completed</option>
                                </select>
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="submitVersion()">Add Version</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Functions for managing feature inputs in the modal
        window.addFeatureInput = function() {
            const featuresList = document.getElementById('features-list');
            const featureInputs = featuresList.querySelectorAll('.feature-input');
            
            const newFeatureInput = document.createElement('div');
            newFeatureInput.className = 'feature-input';
            newFeatureInput.innerHTML = `
                <input type="text" class="feature-text" placeholder="Enter feature description" required>
                <button type="button" class="remove-feature" onclick="removeFeature(this)">Ã—</button>
            `;
            
            featuresList.appendChild(newFeatureInput);
            
            // Show remove buttons if there's more than one input
            const allRemoveButtons = featuresList.querySelectorAll('.remove-feature');
            allRemoveButtons.forEach(btn => btn.style.display = 'inline-block');
        }

        window.removeFeature = function(button) {
            const featureInput = button.parentNode;
            const featuresList = document.getElementById('features-list');
            
            featureInput.remove();
            
            // Hide remove buttons if there's only one input left
            const remainingInputs = featuresList.querySelectorAll('.feature-input');
            if (remainingInputs.length === 1) {
                const lastRemoveButton = remainingInputs[0].querySelector('.remove-feature');
                if (lastRemoveButton) {
                    lastRemoveButton.style.display = 'none';
                }
            }
        }

        // Toggle feature status (cycle through: planned -> in-progress -> completed)
        window.toggleFeatureStatus = async function(featureId, version) {
            const circle = document.querySelector(`[data-feature-id="${featureId}"] .feature-status-circle`);
            if (!circle) return;
            
            let currentStatus = circle.classList.contains('completed') ? 'completed' : 
                              circle.classList.contains('in-progress') ? 'in-progress' : 'planned';
            
            let newStatus;
            switch(currentStatus) {
                case 'planned':
                    newStatus = 'in-progress';
                    break;
                case 'in-progress':
                    newStatus = 'completed';
                    break;
                case 'completed':
                    newStatus = 'planned';
                    break;
            }
            
            // Update circle visually
            circle.classList.remove('planned', 'in-progress', 'completed');
            circle.classList.add(newStatus);
            
            // Update in Firebase
            try {
                await updateFeatureStatusInFirebase(featureId, newStatus, version);
                
                // Update progress bar for the version
                updateVersionProgress(version);
                
                showSuccess(`Feature status updated to ${newStatus}`);
            } catch (error) {
                console.error('Error updating feature status:', error);
                // Revert the visual change if Firebase update failed
                circle.classList.remove('planned', 'in-progress', 'completed');
                circle.classList.add(currentStatus);
                alert('Error updating feature status');
            }
        }

        // Update dashboard counters
        function updateDashboardCounters() {
            // Count current elements in the DOM for immediate feedback
            // Use the correct selectors based on what's actually in the DOM
            const tasksCount = document.querySelectorAll('#tasks-container .note-item-simple').length;
            const notesCount = document.querySelectorAll('#notes-container .note-item-simple').length;
            const versionsCount = document.querySelectorAll('#features-container .version-roadmap-item').length;
            const milestonesCount = document.querySelectorAll('#milestones-timeline .milestone-point').length;
            const expenseItems = document.querySelectorAll('#expenses-container .expense-item-simple');
            
            
            // Calculate total budget used from visible expenses
            let totalBudget = 0;
            expenseItems.forEach(item => {
                const amountText = item.querySelector('.expense-amount-simple')?.textContent;
                if (amountText) {
                    const amount = parseFloat(amountText.replace('$', ''));
                    if (!isNaN(amount)) {
                        totalBudget += amount;
                    }
                }
            });
            
            // Update stats with animation
            updateStatsWithAnimation({
                tasks: tasksCount,
                notes: notesCount,
                versions: versionsCount,
                milestones: milestonesCount,
                budget: totalBudget
            });
        }

        // Update feature status in Firebase
        async function updateFeatureStatusInFirebase(featureId, newStatus, version) {
            // Find the version document that contains this feature
            const featuresQuery = query(
                collection(db, 'appFeatures'),
                where('userId', '==', auth.currentUser.uid),
                where('appId', '==', getCurrentAppId()),
                where('version', '==', version)
            );
            
            const querySnapshot = await getDocs(featuresQuery);
            if (querySnapshot.empty) return;
            
            const versionDoc = querySnapshot.docs[0];
            const versionData = versionDoc.data();
            
            // Update the specific feature in the features array
            const updatedFeatures = versionData.features.map((feature, index) => {
                if (`${versionDoc.id}-feature-${index}` === featureId) {
                    return { ...feature, status: newStatus };
                }
                return feature;
            });
            
            // Update the document
            await updateDoc(doc(db, 'appFeatures', versionDoc.id), {
                features: updatedFeatures
            });
        }

        // Update version progress bar and status
        function updateVersionProgress(version) {
            const versionItem = document.querySelector(`[data-version="${version}"]`);
            if (!versionItem) return;
            
            const circles = versionItem.querySelectorAll('.feature-status-circle');
            const completedCircles = versionItem.querySelectorAll('.feature-status-circle.completed');
            
            const totalFeatures = circles.length;
            const completedFeatures = completedCircles.length;
            const progress = totalFeatures > 0 ? Math.round((completedFeatures / totalFeatures) * 100) : 0;
            
            // Update progress bar
            const progressBar = versionItem.querySelector('.version-progress-fill');
            if (progressBar) {
                progressBar.style.width = progress + '%';
            }
            
            // Update progress text
            const progressText = versionItem.querySelector('.version-progress-text');
            if (progressText) {
                progressText.textContent = `${completedFeatures}/${totalFeatures} features`;
            }
            
            // Update version status badge
            const statusBadge = versionItem.querySelector('.version-status-badge');
            if (statusBadge) {
                let versionStatus = 'planning';
                if (progress === 100) versionStatus = 'completed';
                else if (progress > 0) versionStatus = 'in-progress';
                
                statusBadge.className = `version-status-badge ${versionStatus}`;
                statusBadge.textContent = versionStatus === 'completed' ? 'Released' : 
                                        versionStatus === 'in-progress' ? 'Active' : 'Planned';
                
                // Update version item class
                versionItem.className = `version-roadmap-item ${versionStatus}`;
            }
        }

        // Delete entire version
        window.deleteVersionConfirm = async function(version) {
            if (confirm(`Are you sure you want to delete version ${version} and all its features?`)) {
                try {
                    // Find and delete the version document
                    const featuresQuery = query(
                        collection(db, 'appFeatures'),
                        where('userId', '==', auth.currentUser.uid),
                        where('appId', '==', getCurrentAppId()),
                        where('version', '==', version)
                    );
                    
                    const querySnapshot = await getDocs(featuresQuery);
                    if (!querySnapshot.empty) {
                        const versionDoc = querySnapshot.docs[0];
                        await deleteDoc(doc(db, 'appFeatures', versionDoc.id));
                        
                        showSuccess(`Version ${version} deleted successfully!`);
                        loadAppFeatures(); // Reload the features
                    }
                } catch (error) {
                    console.error('Error deleting version:', error);
                    alert('Error deleting version: ' + error.message);
                }
            }
        }

        window.openExpenseModal = function() {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content minimal">
                    <div class="modal-header">
                        <h3>Add New Expense</h3>
                        <button class="modal-close" onclick="closeModal()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <form id="expense-form">
                            <div class="form-group">
                                <label>Description</label>
                                <input type="text" id="expense-description" placeholder="Enter expense description" required>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Amount ($)</label>
                                    <input type="number" id="expense-amount" step="0.01" placeholder="0.00" required>
                                </div>
                                <div class="form-group">
                                    <label>Category</label>
                                    <select id="expense-category">
                                        <option value="development">Development</option>
                                        <option value="hosting">Hosting</option>
                                        <option value="tools">Tools</option>
                                        <option value="marketing">Marketing</option>
                                        <option value="design">Design</option>
                                        <option value="other">Other</option>
                                    </select>
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Date</label>
                                    <input type="date" id="expense-date" value="${new Date().toISOString().split('T')[0]}" required>
                                </div>
                                <div class="form-group">
                                    <label>Frequency</label>
                                    <select id="expense-frequency">
                                        <option value="one-time">One-time</option>
                                        <option value="weekly">Weekly</option>
                                        <option value="monthly">Monthly</option>
                                        <option value="quarterly">Quarterly</option>
                                        <option value="yearly">Yearly</option>
                                    </select>
                                </div>
                            </div>
                            <div class="form-group">
                                <label>Notes</label>
                                <textarea id="expense-notes" placeholder="Additional notes"></textarea>
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="submitExpense()">Add Expense</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        window.closeModal = function() {
            const modal = document.querySelector('.modal-overlay');
            if (modal) {
                modal.remove();
            }
        }

        // Submit functions (placeholders - these would integrate with your data system)
        window.submitTask = async function() {
            const form = document.getElementById('task-form');
            if (!form.checkValidity()) {
                form.reportValidity();
                return;
            }
            
            try {
                const title = document.getElementById('task-title').value;
                const description = document.getElementById('task-description').value;
                const priority = document.getElementById('task-priority').value;
                const status = document.getElementById('task-status').value;
                const dueDate = document.getElementById('task-due-date').value;
                
                const taskData = {
                    title: title,
                    description: description,
                    priority: priority,
                    status: status,
                    dueDate: dueDate || null,
                    createdAt: new Date().toISOString(),
                    userId: auth.currentUser.uid,
                    appId: getCurrentAppId()
                };

                console.log('Saving task with data:', taskData);
                await addDoc(collection(db, 'appTasks'), taskData);
                
                alert('Task added successfully!');
                closeModal();
                loadAppTasks(); // Refresh the tasks display
                setTimeout(() => updateAllStats(), 500); // Update stats after data loads
                
            } catch (error) {
                console.error('Error adding task:', error);
                alert('Error adding task. Please try again.');
            }
        }

        window.submitNote = async function() {
            const form = document.getElementById('note-form');
            if (!form.checkValidity()) {
                form.reportValidity();
                return;
            }
            
            try {
                const category = document.getElementById('note-category').value;
                const content = document.getElementById('note-content').value;
                const tags = document.getElementById('note-tags').value.split(',').map(tag => tag.trim()).filter(tag => tag);
                
                const noteData = {
                    category: category,
                    content: content,
                    tags: tags,
                    createdAt: new Date().toISOString(),
                    userId: auth.currentUser.uid,
                    appId: getCurrentAppId()
                };

                await addDoc(collection(db, 'appNotes'), noteData);
                
                alert('Note added successfully!');
                closeModal();
                loadAppNotes(); // Refresh the notes display
                setTimeout(() => updateAllStats(), 500); // Update stats after data loads
                
            } catch (error) {
                console.error('Error adding note:', error);
                alert('Error adding note. Please try again.');
            }
        }

        window.submitMilestonesSetup = async function() {
            try {
                const titleInputs = document.querySelectorAll('.milestone-title');
                const dateInputs = document.querySelectorAll('.milestone-date');
                const descriptionInputs = document.querySelectorAll('.milestone-description');
                
                // Validate that all titles are filled
                const milestones = [];
                let hasEmptyTitle = false;
                
                titleInputs.forEach((titleInput, index) => {
                    const title = titleInput.value.trim();
                    if (!title) {
                        hasEmptyTitle = true;
                        return;
                    }
                    
                    const percentage = Math.round(((index + 1) / titleInputs.length) * 100);
                    
                    milestones.push({
                        title: title,
                        description: descriptionInputs[index].value.trim(),
                        targetDate: dateInputs[index].value || null,
                        status: 'planned',
                        progress: percentage,
                        order: index + 1,
                        createdAt: new Date().toISOString(),
                        userId: auth.currentUser.uid,
                        appId: getCurrentAppId()
                    });
                });
                
                if (hasEmptyTitle) {
                    alert('Please fill in all milestone titles.');
                    return;
                }
                
                if (milestones.length === 0) {
                    alert('Please create at least one milestone.');
                    return;
                }
                
                // Save all milestones to Firebase
                const batch = milestones.map(milestone => 
                    addDoc(collection(db, 'appMilestones'), milestone)
                );
                
                await Promise.all(batch);
                
                showSuccess(`${milestones.length} milestones created successfully!`);
                closeModal();
                loadAppMilestones(); // Refresh the milestones display
                setTimeout(() => updateAllStats(), 500); // Update stats after data loads
                
            } catch (error) {
                console.error('Error creating milestones:', error);
                alert('Error creating milestones. Please try again.');
            }
        }

        // Check if milestones already exist for this app
        async function checkMilestonesExistence() {
            try {
                const milestonesQuery = query(
                    collection(db, 'appMilestones'),
                    where('userId', '==', auth.currentUser.uid),
                    where('appId', '==', getCurrentAppId())
                );
                
                const querySnapshot = await getDocs(milestonesQuery);
                return !querySnapshot.empty;
            } catch (error) {
                console.error('Error checking milestones existence:', error);
                return false;
            }
        }

        // Delete all milestones for this app
        window.deleteAllMilestonesConfirm = async function() {
            if (confirm('Are you sure you want to delete ALL milestones? This action cannot be undone.')) {
                try {
                    const milestonesQuery = query(
                        collection(db, 'appMilestones'),
                        where('userId', '==', auth.currentUser.uid),
                        where('appId', '==', getCurrentAppId())
                    );
                    
                    const querySnapshot = await getDocs(milestonesQuery);
                    const deletePromises = [];
                    
                    querySnapshot.forEach((doc) => {
                        deletePromises.push(deleteDoc(doc.ref));
                    });
                    
                    await Promise.all(deletePromises);
                    
                    showSuccess('All milestones deleted successfully!');
                    loadAppMilestones(); // Refresh the display
                    setTimeout(() => updateAllStats(), 500); // Update stats after data loads
                    
                    // Update the action button to show "+" again
                    const actionsContainer = document.querySelector('.unified-dashboard .action-buttons');
                    if (actionsContainer) {
                        actionsContainer.innerHTML = `
                            <button class="plus-button" onclick="openMilestonesSetupModal()" title="Setup Milestones">+</button>
                        `;
                    }
                    
                } catch (error) {
                    console.error('Error deleting milestones:', error);
                    alert('Error deleting milestones: ' + error.message);
                }
            }
        }

        window.submitVersion = async function() {
            const form = document.getElementById('version-form');
            if (!form.checkValidity()) {
                form.reportValidity();
                return;
            }
            
            try {
                const versionName = document.getElementById('version-name').value;
                const versionStatus = document.getElementById('version-status').value;
                
                // Collect all feature descriptions
                const featureInputs = document.querySelectorAll('.feature-text');
                const features = [];
                
                featureInputs.forEach(input => {
                    const featureText = input.value.trim();
                    if (featureText) {
                        features.push({
                            title: featureText,
                            status: versionStatus // All features in the version start with the same status
                        });
                    }
                });
                
                if (features.length === 0) {
                    alert('Please add at least one feature to the version.');
                    return;
                }
                
                // Create a version document that contains multiple features
                const versionData = {
                    version: versionName,
                    status: versionStatus,
                    features: features,
                    createdAt: new Date().toISOString(),
                    userId: auth.currentUser.uid,
                    appId: getCurrentAppId()
                };

                await addDoc(collection(db, 'appFeatures'), versionData);
                
                showSuccess(`Version ${versionName} with ${features.length} feature(s) added successfully!`);
                closeModal();
                loadAppFeatures(); // Refresh the features display
                
            } catch (error) {
                console.error('Error adding version:', error);
                alert('Error adding version. Please try again.');
            }
        }

        window.submitExpense = async function() {
            const form = document.getElementById('expense-form');
            if (!form.checkValidity()) {
                form.reportValidity();
                return;
            }
            
            try {
                const description = document.getElementById('expense-description').value;
                const amount = parseFloat(document.getElementById('expense-amount').value);
                const category = document.getElementById('expense-category').value;
                const date = document.getElementById('expense-date').value;
                const frequency = document.getElementById('expense-frequency').value;
                const notes = document.getElementById('expense-notes').value;
                
                // Validation
                if (!description.trim()) {
                    alert('Please enter a description');
                    return;
                }
                if (isNaN(amount) || amount <= 0) {
                    alert('Please enter a valid amount');
                    return;
                }
                
                const expenseData = {
                    description: description.trim(),
                    amount: amount,
                    category: category,
                    date: date || new Date().toISOString().split('T')[0],
                    frequency: frequency,
                    notes: notes.trim(),
                    createdAt: new Date().toISOString(),
                    userId: auth.currentUser.uid,
                    appId: getCurrentAppId()
                };

                console.log('ðŸ’¾ Saving expense to Firebase:', expenseData);
                const docRef = await addDoc(collection(db, 'appExpenses'), expenseData);
                console.log('âœ… Expense saved with ID:', docRef.id);
                
                const frequencyText = frequency === 'one-time' ? '' : ` (${frequency})`;
                showSuccess(`Expense "${description}"${frequencyText} added successfully!`);
                closeModal();
                
                console.log('ðŸ”„ Refreshing expenses list...');
                loadAppExpenses(); // Refresh the expenses display
                
            } catch (error) {
                console.error('Error adding expense:', error);
                alert('Error adding expense. Please try again.');
            }
        }

        // Edit Mode Functions





        // Delete Confirmation Functions (simplified - called directly from buttons)
        window.deleteTaskConfirm = async function(taskId) {
            if (confirm('Are you sure you want to delete this task?')) {
                try {
                    await deleteDoc(doc(db, 'appTasks', taskId));
                    showSuccess('Task deleted successfully!');
                    loadAppTasks(); // Reload the tasks
                    setTimeout(() => updateAllStats(), 500); // Update stats after data loads
                } catch (error) {
                    console.error('Error deleting task:', error);
                    alert('Error deleting task: ' + error.message);
                }
            }
        }

        window.deleteNoteConfirm = async function(noteId) {
            if (confirm('Are you sure you want to delete this note?')) {
                try {
                    await deleteDoc(doc(db, 'appNotes', noteId));
                    showSuccess('Note deleted successfully!');
                    loadAppNotes(); // Reload the notes
                    setTimeout(() => updateAllStats(), 500); // Update stats after data loads
                } catch (error) {
                    console.error('Error deleting note:', error);
                    alert('Error deleting note: ' + error.message);
                }
            }
        }

        window.deleteFeatureConfirm = async function(featureId) {
            if (confirm('Are you sure you want to delete this feature?')) {
                try {
                    await deleteDoc(doc(db, 'appFeatures', featureId));
                    showSuccess('Feature deleted successfully!');
                    loadAppFeatures(); // Reload the features
                } catch (error) {
                    console.error('Error deleting feature:', error);
                    alert('Error deleting feature: ' + error.message);
                }
            }
        }

        window.deleteExpenseConfirm = async function(expenseId) {
            if (confirm('Are you sure you want to delete this expense?')) {
                try {
                    await deleteDoc(doc(db, 'appExpenses', expenseId));
                    showSuccess('Expense deleted successfully!');
                    loadAppExpenses(); // Reload the expenses
                } catch (error) {
                    console.error('Error deleting expense:', error);
                    alert('Error deleting expense: ' + error.message);
                }
            }
        }




        // Helper function to get current app ID
        function getCurrentAppId() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('id') || urlParams.get('appId') || 'default-app';
        }

        // Helper function to show success messages
        function showSuccess(message) {
            // Create a temporary success notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #28a745;
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                font-size: 14px;
                font-weight: 500;
                animation: slideUp 0.3s ease-out;
            `;
            notification.textContent = message;
            
            // Add animation styles
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideUp {
                    from { transform: translateX(-50%) translateY(100%); opacity: 0; }
                    to { transform: translateX(-50%) translateY(0); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.remove();
                style.remove();
            }, 3000);
        }

        // Helper function to show error messages
        function showError(message) {
            // Create a temporary error notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #dc3545;
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                font-size: 14px;
                font-weight: 500;
                animation: slideUp 0.3s ease-out;
            `;
            notification.textContent = message;
            
            // Add animation styles
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideUp {
                    from { transform: translateX(-50%) translateY(100%); opacity: 0; }
                    to { transform: translateX(-50%) translateY(0); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(notification);
            
            // Remove after 5 seconds
            setTimeout(() => {
                notification.remove();
                style.remove();
            }, 5000);
        }

        // Confirmation popup function
        function showConfirmationPopup(message, onConfirm, onCancel) {
            const popup = document.createElement('div');
            popup.className = 'modal-overlay';
            popup.innerHTML = `
                <div class="modal-content confirmation">
                    <div class="modal-header">
                        <h3>Confirm Action</h3>
                    </div>
                    <div class="modal-body">
                        <p>${message}</p>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" id="confirm-no">No</button>
                        <button class="btn btn-primary" id="confirm-yes">Yes</button>
                    </div>
                </div>
            `;
            document.body.appendChild(popup);
            
            // Add event listeners
            const noButton = popup.querySelector('#confirm-no');
            const yesButton = popup.querySelector('#confirm-yes');
            
            noButton.addEventListener('click', () => {
                popup.remove();
                if (onCancel) onCancel();
            });
            
            yesButton.addEventListener('click', () => {
                popup.remove();
                if (onConfirm) onConfirm();
            });
        }

        // Update functions with confirmation
        window.updateTask = function(taskId) {
            showConfirmationPopup(
                'Do you want to save the changes to this task?',
                async function() {
                    try {
                        const title = document.getElementById('edit-task-title').value;
                        const description = document.getElementById('edit-task-description').value;
                        const priority = document.getElementById('edit-task-priority').value;
                        const status = document.getElementById('edit-task-status').value;
                        
                        const updateData = {
                            title: title,
                            description: description,
                            priority: priority,
                            status: status,
                            updatedAt: new Date().toISOString()
                        };

                        if (taskId && taskId !== 'undefined') {
                            await updateDoc(doc(db, 'appTasks', taskId), updateData);
                        }
                        
                        alert('Task updated successfully!');
                        closeModal();
                        loadAppTasks();
                        
                    } catch (error) {
                        console.error('Error updating task:', error);
                        alert('Error updating task. Please try again.');
                    }
                }
            );
        }

        window.updateNote = function(noteId) {
            showConfirmationPopup(
                'Do you want to save the changes to this note?',
                async function() {
                    try {
                        const category = document.getElementById('edit-note-category').value;
                        const content = document.getElementById('edit-note-content').value;
                        
                        const updateData = {
                            category: category,
                            content: content,
                            updatedAt: new Date().toISOString()
                        };

                        if (noteId && noteId !== 'undefined') {
                            await updateDoc(doc(db, 'appNotes', noteId), updateData);
                        }
                        
                        alert('Note updated successfully!');
                        closeModal();
                        loadAppNotes();
                        
                    } catch (error) {
                        console.error('Error updating note:', error);
                        alert('Error updating note. Please try again.');
                    }
                }
            );
        }

        window.updateMilestone = function(milestoneId) {
            showConfirmationPopup(
                'Do you want to save the changes to this milestone?',
                async function() {
                    try {
                        const title = document.getElementById('edit-milestone-title').value;
                        const description = document.getElementById('edit-milestone-description').value;
                        const progress = parseInt(document.getElementById('edit-milestone-progress').value);
                        const status = document.getElementById('edit-milestone-status').value;
                        
                        const updateData = {
                            title: title,
                            description: description,
                            progress: progress,
                            status: status,
                            updatedAt: new Date().toISOString()
                        };

                        if (milestoneId && milestoneId !== 'undefined') {
                            await updateDoc(doc(db, 'appMilestones', milestoneId), updateData);
                        }
                        
                        alert('Milestone updated successfully!');
                        closeModal();
                        loadAppMilestones();
                        
                    } catch (error) {
                        console.error('Error updating milestone:', error);
                        alert('Error updating milestone. Please try again.');
                    }
                }
            );
        }

        window.updateFeature = function(featureId) {
            showConfirmationPopup(
                'Do you want to save the changes to this feature?',
                async function() {
                    try {
                        const name = document.getElementById('edit-feature-title').value;
                        const description = document.getElementById('edit-feature-description').value;
                        const version = document.getElementById('edit-feature-version').value;
                        const status = document.getElementById('edit-feature-status').value;
                        
                        const updateData = {
                            name: name,
                            description: description,
                            version: version,
                            status: status,
                            updatedAt: new Date().toISOString()
                        };

                        if (featureId && featureId !== 'undefined') {
                            await updateDoc(doc(db, 'appFeatures', featureId), updateData);
                        }
                        
                        alert('Feature updated successfully!');
                        closeModal();
                        loadAppFeatures();
                        
                    } catch (error) {
                        console.error('Error updating feature:', error);
                        alert('Error updating feature. Please try again.');
                    }
                }
            );
        }

        window.updateExpense = function(expenseId) {
            showConfirmationPopup(
                'Do you want to save the changes to this expense?',
                async function() {
                    try {
                        const description = document.getElementById('edit-expense-description').value;
                        const amount = parseFloat(document.getElementById('edit-expense-amount').value);
                        const category = document.getElementById('edit-expense-category').value;
                        const date = document.getElementById('edit-expense-date').value;
                        
                        const updateData = {
                            description: description,
                            amount: amount,
                            category: category,
                            date: date,
                            updatedAt: new Date().toISOString()
                        };

                        if (expenseId && expenseId !== 'undefined') {
                            await updateDoc(doc(db, 'appExpenses', expenseId), updateData);
                        }
                        
                        alert('Expense updated successfully!');
                        closeModal();
                        loadAppExpenses();
                        
                    } catch (error) {
                        console.error('Error updating expense:', error);
                        alert('Error updating expense. Please try again.');
                    }
                }
            );
        }

        // Add Recurring Expense Function
        window.addRecurringExpense = function() {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3><i class="fas fa-redo"></i> Add Recurring Expense</h3>
                        <button class="modal-close" onclick="closeRecurringExpenseModal()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <form id="recurring-expense-form">
                            <div class="form-group">
                                <label>Description</label>
                                <input type="text" id="recurring-description" placeholder="e.g., Domain Hosting" required>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Amount ($)</label>
                                    <input type="number" id="recurring-amount" step="0.01" placeholder="0.00" required>
                                </div>
                                <div class="form-group">
                                    <label>Frequency</label>
                                    <select id="recurring-frequency" required>
                                        <option value="monthly">Monthly</option>
                                        <option value="yearly">Yearly</option>
                                        <option value="weekly">Weekly</option>
                                        <option value="quarterly">Quarterly</option>
                                    </select>
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Category</label>
                                    <select id="recurring-category" required>
                                        <option value="hosting">Hosting</option>
                                        <option value="tools">Tools</option>
                                        <option value="development">Development</option>
                                        <option value="marketing">Marketing</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Start Date</label>
                                    <input type="date" id="recurring-start-date" required>
                                </div>
                            </div>
                            <div class="form-group">
                                <label>Notes (Optional)</label>
                                <textarea id="recurring-notes" placeholder="Additional details..."></textarea>
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeRecurringExpenseModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="submitRecurringExpense()">Add Recurring Expense</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Set default start date to today
            document.getElementById('recurring-start-date').value = new Date().toISOString().split('T')[0];
        }

        window.closeRecurringExpenseModal = function() {
            const modal = document.querySelector('.modal-overlay');
            if (modal) {
                modal.remove();
            }
        }

        window.submitRecurringExpense = function() {
            const form = document.getElementById('recurring-expense-form');
            if (!form.checkValidity()) {
                form.reportValidity();
                return;
            }

            const recurringExpense = {
                id: Date.now(),
                description: document.getElementById('recurring-description').value,
                amount: parseFloat(document.getElementById('recurring-amount').value),
                frequency: document.getElementById('recurring-frequency').value,
                category: document.getElementById('recurring-category').value,
                startDate: document.getElementById('recurring-start-date').value,
                notes: document.getElementById('recurring-notes').value,
                isRecurring: true,
                nextDue: calculateNextDue(document.getElementById('recurring-start-date').value, document.getElementById('recurring-frequency').value),
                createdAt: new Date().toISOString()
            };

            // Add to existing expenses array (in a real app, this would go to a separate recurring expenses collection)
            if (!window.appExpenses) {
                window.appExpenses = [];
            }
            
            window.appExpenses.push(recurringExpense);
            
            // Re-render expenses
            renderExpenses();
            
            closeRecurringExpenseModal();
            
            // Show success message
            alert('Recurring expense added successfully!');
        }

        function calculateNextDue(startDate, frequency) {
            const date = new Date(startDate);
            const now = new Date();
            
            // If start date is in the future, return start date
            if (date > now) {
                return date.toISOString().split('T')[0];
            }
            
            // Calculate next occurrence
            switch (frequency) {
                case 'weekly':
                    while (date <= now) {
                        date.setDate(date.getDate() + 7);
                    }
                    break;
                case 'monthly':
                    while (date <= now) {
                        date.setMonth(date.getMonth() + 1);
                    }
                    break;
                case 'quarterly':
                    while (date <= now) {
                        date.setMonth(date.getMonth() + 3);
                    }
                    break;
                case 'yearly':
                    while (date <= now) {
                        date.setFullYear(date.getFullYear() + 1);
                    }
                    break;
            }
            
            return date.toISOString().split('T')[0];
        }

        // Helper functions
        function getStatusColor(status) {
            switch(status) {
                case 'Completed': return 'success';
                case 'In Progress': return 'warning';
                case 'Pending': return 'secondary';
                default: return 'secondary';
            }
        }

        function getPriorityColor(priority) {
            switch(priority) {
                case 'High': return 'danger';
                case 'Medium': return 'warning';
                case 'Low': return 'info';
                default: return 'secondary';
            }
        }

        // Global functions for actions
        window.linkExistingSpec = function() {
            alert('To link specifications to this app, go to your Profile page and use the Link button on each specification.');
        };

        window.createNewSpec = function() {
            window.location.href = '../processing-unified.html';
        };

        window.addMarketResearch = function() {
            alert('To link market research to this app, go to your Profile page and use the Link button on each research item.');
        };

        // Function to clean up invalid research links
        window.cleanupResearchLinks = async function() {
            if (!currentApp || !currentApp.linkedResearch || !currentUser) return;
            
            const validResearchIds = [];
            
            for (const researchId of currentApp.linkedResearch) {
                try {
                    // Try to load from marketResearch collection first
                    let researchDoc = await getDoc(doc(db, 'marketResearch', researchId));
                    
                    if (!researchDoc.exists()) {
                        // If not found, try specs collection with mode: "market"
                        researchDoc = await getDoc(doc(db, 'specs', researchId));
                    }
                    
                    if (researchDoc.exists()) {
                        validResearchIds.push(researchId);
                    }
                } catch (error) {
                    console.warn('Skipping invalid research ID:', researchId);
                }
            }
            
            // Update the app with only valid research IDs
            if (validResearchIds.length !== currentApp.linkedResearch.length) {
                try {
                    await updateDoc(doc(db, 'apps', currentApp.id), {
                        linkedResearch: validResearchIds
                    });
                    console.log('Cleaned up research links:', validResearchIds);
                    // Reload the app data
                    loadAppData();
                } catch (error) {
                    console.error('Error cleaning up research links:', error);
                }
            }
        };

        // Auth UI functions
        function updateAuthUI(user) {
            const authButtons = document.getElementById('auth-buttons');
            
            if (user) {
                authButtons.innerHTML = `
                    <div class="user-info" onclick="window.location.href='profile.html'">
                        <div class="user-avatar">${user.displayName ? user.displayName.charAt(0).toUpperCase() : user.email.charAt(0).toUpperCase()}</div>
                        <span class="user-name">${user.displayName || user.email.split('@')[0]}</span>
                    </div>
                `;
            } else {
                authButtons.innerHTML = `
                    <button class="auth-btn" onclick="showLoginModal()">Login</button>
                `;
            }
            
            // Update mobile auth UI if function exists
            if (window.updateMobileAuthUI) {
                window.updateMobileAuthUI(user);
            }
        }

        // Global auth functions
        window.logout = function() {
            signOut(auth)
                .then(() => {
                    alert('Logged out successfully');
                    window.location.href = '../index.html';
                })
                .catch(error => {
                    alert('Logout error: ' + error.message);
                });
        };

        window.toggleUserDropdown = function() {
            const dropdown = document.querySelector('.user-dropdown-content');
            if (dropdown) {
                dropdown.classList.toggle('show');
            }
        };

        // End of Dashboard JavaScript

        // User dropdown functionality
        document.addEventListener('click', function(event) {
            const userDropdown = document.querySelector('.user-dropdown');
            const userInfo = document.querySelector('.user-info');
            const dropdown = document.querySelector('.user-dropdown-content');
            
            if (userDropdown && dropdown && dropdown.classList.contains('show') && 
                !userInfo.contains(event.target)) {
                dropdown.classList.remove('show');
            }
        });

        // Back to Profile Function
        window.goBackToProfile = function() {
            // Get the current user ID from the URL or localStorage
            const urlParams = new URLSearchParams(window.location.search);
            const userId = urlParams.get('userId') || localStorage.getItem('currentUserId');
            
            if (userId) {
                // Redirect to profile page with user ID
                window.location.href = `profile.html?id=${userId}`;
            } else {
                // Fallback to profile page without ID
                window.location.href = 'profile.html';
            }
        };

        // Smooth counter animation function
        function animateCounter(element, target, duration = 1500) {
            const start = 0;
            const startTime = performance.now();
            
            function updateCounter(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function for smooth animation
                const easeOutQuart = 1 - Math.pow(1 - progress, 4);
                const current = Math.floor(start + (target - start) * easeOutQuart);
                
                element.textContent = current;
                
                if (progress < 1) {
                    requestAnimationFrame(updateCounter);
                } else {
                    element.textContent = target;
                }
            }
            
            requestAnimationFrame(updateCounter);
        }

        // Track if animation is already running
        let isAnimating = false;

        // Update all stats with smooth animation
        function updateStatsWithAnimation(stats) {
            // If animation is already running, just update the final values without animation
            if (isAnimating) {
                document.getElementById('tasks-count').textContent = stats.tasks;
                document.getElementById('milestones-count').textContent = stats.milestones;
                document.getElementById('notes-count').textContent = stats.notes;
                document.getElementById('versions-count').textContent = stats.versions;
                document.getElementById('budget-used').textContent = `$${stats.budget.toFixed(0)}`;
                return;
            }

            isAnimating = true;
            
            // Start all counters at 0
            document.getElementById('tasks-count').textContent = '0';
            document.getElementById('milestones-count').textContent = '0';
            document.getElementById('notes-count').textContent = '0';
            document.getElementById('versions-count').textContent = '0';
            
            // Animate counters with slight delays for staggered effect
            setTimeout(() => animateCounter(document.getElementById('tasks-count'), stats.tasks), 100);
            setTimeout(() => animateCounter(document.getElementById('milestones-count'), stats.milestones), 200);
            setTimeout(() => animateCounter(document.getElementById('notes-count'), stats.notes), 300);
            
            // Handle version separately (not a number)
            setTimeout(() => {
                document.getElementById('versions-count').textContent = stats.versions;
            }, 400);
            
            // Update budget (no animation needed)
            document.getElementById('budget-used').textContent = `$${stats.budget.toFixed(0)}`;
            
            // Reset animation flag after animation completes
            setTimeout(() => {
                isAnimating = false;
            }, 2000);
        }

        // Calculate and update all stats from loaded data
        function updateAllStats() {
            // Use the existing updateDashboardCounters function
            updateDashboardCounters();
        }
    </script>
    

    </main>
    
    <!-- Footer -->
    <!-- Footer -->
<footer>
  <div class="footer-content">
    <div class="footer-links">
      <a href="/pages/how.html" aria-label="Learn how specifys.ai works">How It Works</a>
      <a href="/pages/about.html" aria-label="Learn more about specifys.ai">About Us</a>
      <a href="/blog/" aria-label="Visit our blog">Blog</a>
      <a href="/tools/map/vibe-coding-tools-map.html" aria-label="Explore Vibe Coding Tools Map">Vibe Coding Tools Map</a>
      <a href="/pages/ToolPicker.html" aria-label="Use our Tool Finder">Tool Finder</a>
    </div>
    <span class="footer-divider">|</span>
    <div class="footer-social">
      <a href="https://www.linkedin.com/company/specifys-ai/" target="_blank" aria-label="Follow us on LinkedIn"><i class="fab fa-linkedin-in"></i></a>
      <a href="https://www.facebook.com/profile.php?id=61576402600129&locale=he_IL" target="_blank" aria-label="Follow us on Facebook"><i class="fab fa-facebook-f"></i></a>
      <a href="mailto:specifysai@gmail.com" aria-label="Send us an email"><i class="fas fa-envelope"></i></a>
      <a href="https://www.producthunt.com/products/specifys-ai" target="_blank" aria-label="Check us out on Product Hunt"><i class="fab fa-product-hunt"></i></a>
    </div>
  </div>
  <div class="footer-copyright">
    Â© 2025 specifys.ai. All rights reserved. <span class="footer-version">v1.2.3</span>
  </div>
</footer>

    
    <!-- Scroll to top button -->
    <!-- Scroll to top button -->
<button class="icon-btn scroll-to-top" id="scrollToTop" aria-label="Scroll">
  <i class="fas fa-arrow-up"></i>
</button>

<script>
  // Scroll button functionality
  document.addEventListener('DOMContentLoaded', function() {
    const scrollBtn = document.getElementById('scrollToTop');
    
    if (scrollBtn) {
      // Handle click - scroll to top or bottom based on current state
      scrollBtn.addEventListener("click", () => {
        if (window.scrollY > 300) {
          // If scrolled down, go to top
          window.scrollTo({ top: 0, behavior: "smooth" });
        } else {
          // If at top, scroll to bottom
          window.scrollTo({ top: document.body.scrollHeight, behavior: "smooth" });
        }
      });
      
      // Rotate button based on scroll position
      window.addEventListener("scroll", () => {
        if (window.scrollY > 300) {
          scrollBtn.classList.add("scrolled-down");
          scrollBtn.setAttribute("aria-label", "Scroll to top");
        } else {
          scrollBtn.classList.remove("scrolled-down");
          scrollBtn.setAttribute("aria-label", "Scroll to bottom");
        }
      });
    }
  });
</script>


    
    <!-- Firebase SDK & Auth -->
    
    <!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

<script>
  // Firebase Configuration
  const firebaseConfig = {
    apiKey: "AIzaSyB9hr0IWM4EREzkKDxBxYoYinV6LJXWXV4",
    authDomain: "specify-ai.firebaseapp.com",
    projectId: "specify-ai",
    storageBucket: "specify-ai.firebasestorage.app",
    messagingSenderId: "734278787482",
    appId: "1:734278787482:web:0e312fb6f197e849695a23",
    measurementId: "G-4YR9LK63MR"
  };

  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();
</script>


    <script>
  // Auth UI functions
  function updateAuthUI(user) {
    const authButtons = document.getElementById('auth-buttons');
    if (!authButtons) return;
    
    if (user) {
      // User is logged in
      const displayName = user.displayName || user.email.split('@')[0];
      const firstLetter = displayName.charAt(0).toUpperCase();
      
      authButtons.innerHTML = `
        <a href="/pages/profile.html" class="user-info" style="text-decoration: none;">
          <div class="user-avatar">${firstLetter}</div>
          <span>${displayName}</span>
        </a>
      `;
    } else {
      // User is not logged in
      authButtons.innerHTML = `
        <button class="auth-btn" onclick="showLoginModal()">Login</button>
      `;
    }
  }

  // Global auth functions
  window.showLoginModal = function() {
    if (typeof trackButtonClick !== 'undefined') {
      trackButtonClick('Show Login', 'Authentication', 'header');
    }
    window.location.href = '/pages/auth.html';
  };

  window.showRegisterModal = function() {
    if (typeof trackButtonClick !== 'undefined') {
      trackButtonClick('Show Register', 'Authentication', 'header');
    }
    window.location.href = '/pages/auth.html';
  };

  window.logout = function() {
    if (typeof trackAuthEvent !== 'undefined') {
      trackAuthEvent('logout', 'email');
    }
    auth.signOut()
      .then(() => {
        console.log('Logged out successfully');
      })
      .catch(error => {
        console.error('Error logging out:', error);
      });
  };

  // Listen to auth state changes
  auth.onAuthStateChanged((user) => {
    updateAuthUI(user);
  });

  // Initialize auth buttons with default state
  document.addEventListener('DOMContentLoaded', function() {
    const authButtons = document.getElementById('auth-buttons');
    if (authButtons && !authButtons.innerHTML.trim()) {
      authButtons.innerHTML = `
        <button class="auth-btn login-btn">Login</button>
      `;
      
      const loginBtn = authButtons.querySelector('.login-btn');
      if (loginBtn) {
        loginBtn.addEventListener('click', function(event) {
          event.stopPropagation();
          window.location.href = '/pages/auth.html';
        });
      }
    }
  });
</script>


    
    
    <!-- Extra JavaScript -->
    
    
</body>
</html>
